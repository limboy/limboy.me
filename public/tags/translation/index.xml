<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Limboy - translation</title>
        <link>https://limboy.me</link>
        <description></description>
        <generator>Zola</generator>
        <language>zh</language>
        <atom:link href="https://limboy.me/tags/translation/index.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Tue, 24 Aug 2021 00:00:00 +0000</lastBuildDate>
        
        <item>
            <title>WaitButWhy - The Tail End(你的时间的尾端)</title>
            <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/wbw-the-tail-end/</link>
            <guid>https://limboy.me/posts/wbw-the-tail-end/</guid>
            <description>&lt;p&gt;这是我很喜欢的博客 &lt;a href=&quot;https:&#x2F;&#x2F;waitbutwhy.com&#x2F;2015&#x2F;12&#x2F;the-tail-end.html&quot;&gt;WaitButWhy&lt;&#x2F;a&gt; 2015 年的一篇文章。我们都知道人生短暂，可到底是怎么个短法？10 年是个模糊的表述，我们很难在脑海里想象 10 年是什么概念。10 个冬天，跟父母在一起 100 天，这样就会更直观些。Tim Urban（文章作者）对人生的时间进行了拆解，将它可视化，映射为各类事件，看看人生时间的尾端到底意味着什么。以下为译文：&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;waitbutwhy.com&#x2F;2014&#x2F;05&#x2F;life-weeks.html&quot;&gt;去年的一篇文章&lt;&#x2F;a&gt;，我们直观地展示了人的寿命。按年份划分：
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544160-d197ee58-cb43-4dd8-93a8-b76beeda7b09.jpg&quot; alt=&quot;Years&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;按月：
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544134-8ae008fd-2a74-4538-915e-0c41d73a4dec.jpg&quot; alt=&quot;Months&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;按周：
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544150-9b364768-efa1-42b0-8ac2-4e1d277c4522.png&quot; alt=&quot;Weeks&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在写那篇文章时，我还做了个按天的，但看起来有点多，所以没有放上去，现在把它放出来:
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544126-91747935-c386-4147-a90c-a0d3d1650669.png&quot; alt=&quot;Days&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;日表带给我的震撼不比周表少。每一个点都是具体的日子，周二，周五或周日。即使有幸能活到 90 岁高龄，也可以在一张纸上记录下每一天。&lt;&#x2F;p&gt;
&lt;p&gt;那篇文章发布后，我一直在想一些其他的事情。除了用时间来衡量生命，还可以用事件来体现。以我自己为例：&lt;&#x2F;p&gt;
&lt;p&gt;我今年 34 岁，乐观一点能画火柴小人（这里指 WaitButWhy 网站）到 90 岁。这样的话，我还能经历不到 60 个冬天：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544158-dcf85249-39a5-4824-bc1a-f9e7137414b6.png&quot; alt=&quot;Winters&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;大约 60 次超级碗(Superbowls):
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544147-34424ace-7f96-4a95-8e9c-1987bdaa37de.png&quot; alt=&quot;Superbowls&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;大海很冷，经常泡在里面也非我要的体验，所以一年游一次差不多了。这么说来，我只能再游个 60 次：
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544137-d8add20f-8663-4c50-aa8f-e53a0a4b3477.png&quot; alt=&quot;Ocean&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;除了为 WaitButWhy 做调研之外，一年大概读 5 本书，总以为将来可以读很多很多书，但事实上只有 300 本，并且希望将来没什么事情可以打断这个习惯
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544108-8c84c6a8-58c3-466b-a81d-f1b8ea9714ea.png&quot; alt=&quot;books&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我在波士顿长大，一直去看红袜队的比赛，但如果我不搬回去，我可能会继续以目前大约每三年去看一次红袜队比赛的节奏，也就是 20 次
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544145-be7184d2-359d-49a6-81ac-1fe6d2380c2d.png&quot; alt=&quot;sox&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我经历过 8 次总统选举，还可以参与 15 次，见过 5 位总统，没有什么意外，我还会再看到大约 9 位
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544144-1697b1bd-543f-46e6-afa1-8eb3258aad5a.png&quot; alt=&quot;presidents&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我大约一个月吃一次披萨，所以还有 700 多次吃披萨的机会。但对饺子我更乐观些。我一个月要吃两次饺子，每次至少吃 6 个，所以饺子的量还是比较富裕的
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544129-07f251a2-df6c-4c34-9fe3-2c8cbf0bb961.png&quot; alt=&quot;dumplings-small&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;但这些事情不是我一直在想的。上面提到的大多数事情在我生命中，每年都以相似的频率发生。如果我的人生已经走过了 1&#x2F;3，我也已经体验了 1&#x2F;3 的事件。&lt;&#x2F;p&gt;
&lt;p&gt;我一直在想生活中非常重要的一部分，与上面这些例子不同，它并没有随着时间的推移而均匀地发生——这种比例与我度过的时间完全不一致：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;人际关系（父母&#x2F;亲属&#x2F;朋友）。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我的父母已经 60 多岁了。18 岁之前，我差不多有 90% 的时间和父母在一起。但自从去上大学，然后搬出波士顿，我可能每年只见他们 5 次，每次 2 天左右。一年 10 天。是我童年时期的 3%。&lt;&#x2F;p&gt;
&lt;p&gt;乐观一点，假如当我 60 岁时，父母还都健在，那么还有大约 30 年的时间。如果保持每年 10 天的频率，大约还有 300 天能跟父母在一起，比小时候一年的时间都少。&lt;&#x2F;p&gt;
&lt;p&gt;面对现实，你会意识到即使没有到人生的终点，对于生命中最重要的一些人，你也已经到了时间的尽头。如果我把已经和将要跟父母在一起的事件画出来，就会非常明显了：
&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;35974&#x2F;130544140-a0056b2d-c60a-4d3b-98a9-3179226bb234.png&quot; alt=&quot;parents-small&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当我高中毕业，跟父母在一起的时间就已经用掉了 93%。我现在正享受那最后的 5% 的时间，我们已经来到了尾声。&lt;&#x2F;p&gt;
&lt;p&gt;跟我的两个姐姐也是差不多的情况。在一起住了 10 年和 13 年后，我现在跟他们住在不同的城市，每年会跟每个人各聚 15 天左右。希望这给我们留下大约 15% 的时间。&lt;&#x2F;p&gt;
&lt;p&gt;老朋友也一样。读高中时，我跟要好的 4 位同学一星期有 5 天在一起。4 年时间相聚 700 次。现在，我们 5 人分散在全国各地，生活和时间表完全不一样，每 10 年可能能聚个 10 天，这个小团体的时间已经是最后的 7% 了。&lt;&#x2F;p&gt;
&lt;p&gt;有了这些信息后，我们能做什么呢？&lt;&#x2F;p&gt;
&lt;p&gt;抛开技术进步能让我活到 700 岁之外，这三点是值得注意的：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1) 跟你在乎的人尽量住的近些。&lt;&#x2F;strong&gt; 在同一个城市和其他城市相比，在一起的时间能差 10 倍。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;2) 注重优先级。&lt;&#x2F;strong&gt; 余下的时间要跟谁打照面取决于哪些人会在你的见面优先级列表上。确保这个列表是你自己而不是无意识的惯性设定的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;3) 注重时间的质量。&lt;&#x2F;strong&gt; 如果跟你在乎的人相处的时间只剩 10%（与之前在一起的时间相比），当你和他们在一起时，把这个事实放在脑海中，并珍视那段时间。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Bonus: Kurzgesagt(德语中 In a nutshell 的意思) 基于这篇文章出了一部短视频：&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JXeJANDKwDc&quot;&gt;What Are You Doing With Your Life? The Tail End&lt;&#x2F;a&gt;，通过动画更直观地把人这一生，事件，剩余时间，意外等描绘了出来，值得一看。&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>[译] Paul Graham: Life is Short</title>
            <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/life-is-short/</link>
            <guid>https://limboy.me/posts/life-is-short/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;Paul Graham 5 年前的&lt;a href=&quot;http:&#x2F;&#x2F;www.paulgraham.com&#x2F;vb.html&quot;&gt;文章&lt;&#x2F;a&gt;，表述了他对「生命短暂」的一些感受，发现还没有比较好的译文，就翻译了下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;众所周知，生命是短暂的。当我还是个孩子的时候，我曾经怀疑过这个问题。生命是真的短暂，还是我们只是在抱怨生命的有限？如果我们活了 10 倍的时间，我们是否也会觉得生命很短？&lt;&#x2F;p&gt;
&lt;p&gt;似乎无法回答这个问题，就没再去想它。等我有了孩子后，再来看这个问题，我想我有答案了：生命确实是短暂的。&lt;&#x2F;p&gt;
&lt;p&gt;有了孩子后，我知道了如何将一个连续的量，即时间，转换成离散的量。你只有 52 个周末和你两岁的孩子在一起。如果有魔法的圣诞节从 3 岁持续到 10 岁，你只能看着你的孩子体验 8 次。8 次并不是很多的东西。好比你握了 8 颗花生，或者一个书架上有 8 本书可供选择，无论你的寿命有多长，数量肯定会很有限。&lt;&#x2F;p&gt;
&lt;p&gt;好吧，那么生命实际上是短暂的。知道这个又会怎样呢？&lt;&#x2F;p&gt;
&lt;p&gt;对我来说有。这意味着「人生苦短，莫把时间耗费在了 x 上」这样的论点有很大的力量，而不仅仅是一个比喻。如果可以的话，应该试着消除这些 x。&lt;&#x2F;p&gt;
&lt;p&gt;如果你问自己，你的时间花在了哪些不必要（bullshit）的事情上，你可能已经知道答案了。可有可无的会议，无意义的争端，官僚主义，装腔作势，处理别人的错误，交通堵塞，令人上瘾但没有回报的消遣。&lt;&#x2F;p&gt;
&lt;p&gt;它们有两种方式融入到你的生活：要么是强迫你，要么是欺骗你。在某种程度上，你必须忍受环境强加给你的 bullshit，因为你需要挣钱。事实上，供求法则解释了这一点：某种工作越有回报，人们就越会去做。不过，强迫你做的 bullshit 可能比你想象的要少。但也有很多人选择放弃这种「磨练」，搬到传统意义上机会较少，但更贴近生活的地方。这可能会变得越来越普遍。&lt;&#x2F;p&gt;
&lt;p&gt;你可以在不搬家的情况下，一定程度上做到这一点。你必须花在 bullshit 上的时间因雇主而不同。虽然大多数大型组织（包括许多小型组织）都无法幸免，但如果你有意识地把避免 bullshit 放在首位，而不是其他因素（如金钱和声望），有可能会找到那些能减少浪费你时间的雇主。&lt;&#x2F;p&gt;
&lt;p&gt;如果你是一个自由职业者或经营一家小公司，你可以在客户层面上做到这一点。如果你放弃或避开那些「有毒」的客户，就可以减少 bullshit 的事情。&lt;&#x2F;p&gt;
&lt;p&gt;虽然有些 bullshit 不可避免地被强加在你身上，但那些通过欺骗你而潜入你生活的 bullshit 就是自己的原因了。自己选择的 bullshit 可能比被迫的 bullshit 更难消除。引诱你浪费时间的事情非常善于欺骗你。我们都熟悉的一个例子是在网上争论。当有人反驳你时，会感觉是在攻击你。当被攻击时，你的本能是为自己辩护。但是像很多本能一样，这个本能并不是为我们当今生活的世界设计的。大多数时候最好不要为自己辩护（避免陷进去）。不然你的生命就会被这些人剥夺。&lt;&#x2F;p&gt;
&lt;p&gt;网上争论只是偶然让人上瘾。还有比这更危险的事情。正如我以前写过的，技术进步的一个副产品是，我们喜欢的东西往往变得更容易上瘾。这意味着我们需要越来越有意识地努力避免上瘾--抽离出另一个自己，问「我想这样度过我的时间吗？」&lt;&#x2F;p&gt;
&lt;p&gt;除了避免 bullshit 之外，人们应该积极寻找重要的事情。但不同事情对不同的人重要程度都不一样，大多数人必须了解什么对他们是重要的。少数人很幸运，很早就意识到他们喜欢数学、照顾动物或写作，然后想办法花大量的时间去做。但是大多数人的生活开始时是由重要的事情和不重要的事情组成的，然后逐渐学会区分它们。&lt;&#x2F;p&gt;
&lt;p&gt;对年轻人来说，这种困惑大部分是由他们所处的环境引起的。在初中和高中，其他孩子对你的看法似乎是世界上最重要的事情。但是，当你问成年人他们在那个年龄段犯了什么错误时，几乎所有人都说他们太在乎其他孩子对自己的看法。&lt;&#x2F;p&gt;
&lt;p&gt;区分重要事物的一个启发式方法是问自己：你将来是否会关心它。假装重要的东西通常有一个看起来很重要的点。这就是它欺骗你的方式。曲线下的面积很小，但其形状像针一样刺入你的意识。&lt;&#x2F;p&gt;
&lt;p&gt;重要的事情不一定是那些人们称之为「重要 」的事情。与朋友喝咖啡很重要。在以后的你看来，不会觉得那是在浪费时间。&lt;&#x2F;p&gt;
&lt;p&gt;有小孩子的一个好处是，他们让你花时间在重要的事情上：他们。当你盯着手机时，他们会抓住你的袖子，说「你能和我一起玩吗？」 这有可能是最不 bullshit 的选择。&lt;&#x2F;p&gt;
&lt;p&gt;如果生命是短暂的，我们应该预期到它的短暂会让我们大吃一惊。你认为事情是理所当然的，然后它们就消失了。你认为你可以永远写那本书，或爬那座山，或其他什么，然后你意识到时机已经错过了。最不可挽回的时机是在他人死亡的时候。他们的生命也很短暂。我母亲去世后，我希望我有更多的时间陪她。我活得好像她会一直在那里一样。她以她典型的安静方式加强了这种错觉。但那是幻觉。 我想很多人都会犯和我一样的错误。&lt;&#x2F;p&gt;
&lt;p&gt;避免被某些事情吓到的方法通常是有意识地意识到它。在生活非常不稳定的时候，过去的人们对死亡的认识达到了现在看起来有点病态的程度。我不知道为什么，但不断提醒自己有一个死神在每个人的肩膀上徘徊，似乎不是正确的答案。也许一个更好的解决方案是反过来看。培养一种对你最想做的事情不耐烦的态度。在攀登那座山或写那本书或看望你的母亲之前不要等待。你不需要不断地提醒自己为什么你不应该等待。只是不要等待。&lt;&#x2F;p&gt;
&lt;p&gt;我还能想到当一个人没有多少东西的时候会做的两件事：试图获得更多的东西，以及品味自己拥有的东西。这两件事在这里都有意义。&lt;&#x2F;p&gt;
&lt;p&gt;你如何生活会影响你的寿命。大多数人可以做得更好。比如我。&lt;&#x2F;p&gt;
&lt;p&gt;但是，通过更密切地关注你所拥有的时间，可能会有更好的效果。让日子匆匆过去是很容易的。富有想象力的人非常喜欢的 「flow」状态的另一面是无法在每天的工作和琐事中暂停下来品味生活。我读过的最引人注目的东西之一不是在书中，而是书的标题：詹姆斯-萨尔特的《燃烧的日子》（Burning the Days）。&lt;&#x2F;p&gt;
&lt;p&gt;在一定程度上减缓时间是可能的。这方面我也越做越好了（在孩子们的帮助下）。当你有小孩子的时候，有很多时刻是如此完美，让你无法不注意到。&lt;&#x2F;p&gt;
&lt;p&gt;从过去的经历中习得些什么确实有帮助。我对我母亲感到悲伤的原因不仅仅是我想念她，而是我想到了所有我们可以做但没有做的事情。我的大儿子很快就 7 岁了。虽然我怀念 3 岁的他，但至少我对过去的事情没有任何遗憾。我们拥有一个父亲和一个 3 岁孩子所拥有的最美好的时光。&lt;&#x2F;p&gt;
&lt;p&gt;尽可能减少 bullshit 的事情，别老是等着去做重要的事情，品味你所拥有的时间。这就是短暂的生命旅程中该做的事情。&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>如何努力工作</title>
            <pubDate>Sat, 16 Feb 2019 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/how-to-work-hard/</link>
            <guid>https://limboy.me/posts/how-to-work-hard/</guid>
            <description>&lt;p&gt;Paul Graham 最近写了篇文章 &lt;a href=&quot;http:&#x2F;&#x2F;paulgraham.com&#x2F;hwh.html&quot;&gt;How to Work Hard&lt;&#x2F;a&gt;，看了之后较有感触，就翻译了下，以下为译文。&lt;&#x2F;p&gt;
&lt;p&gt;关于如何努力工作，似乎没有什么可说的，任何上过学的人都知道。有一些 12 岁的孩子，他们的努力程度令人吃惊。但现在我对「努力工作」又有了更深的理解。&lt;&#x2F;p&gt;
&lt;p&gt;我知道如果想做伟大的事情，就必须非常努力地工作。我小时候对这一点并不确定：学校作业的难度各不相同；一个人并不总是要非常努力才能做得好。而一些牛人似乎不费吹灰之力就能把事情做好。我曾经认为是不是可以通过纯粹的聪明才智来达到目的？现在我知道了，没有。&lt;&#x2F;p&gt;
&lt;p&gt;一些学科看起来很容易的原因是我的学校的标准很低。而牛人似乎毫不费力的原因是多年的实践；他们使事情看起来很容易。&lt;&#x2F;p&gt;
&lt;p&gt;当然，那些牛人通常也有天赋。要取得杰出的成绩需要有三个要素：天赋、实践和努力。只用其中两个就可以做得很好，但要做到最好，则需要全部三个：你需要有很好的天赋，经过大量的练习，并且要非常努力。&lt;&#x2F;p&gt;
&lt;p&gt;例如，比尔-盖茨是他那个时代商业领域最聪明的人之一，同时也是最勤奋的人之一。他说：&amp;quot;我在二十多岁时从未休息过一天，一次都没有。&amp;quot; 梅西的情况也类似，他有很好的天赋，但当他的青年教练谈到他时，他们记住的不是他的天赋，而是他的奉献精神和求胜欲望。如果让我选择 20 世纪最佳英国作家的话，我会投 P.G.Wodehouse 一票。74 岁时，他写道：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;我每写一本新书，就像我在文学的花园里摘了一个柠檬。这确实是一件好事，它使人保持清醒的头脑，使人把每句话重写 10 遍。很多情况下甚至是 20 遍。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;听起来有点极端。但是比尔-盖茨听起来更极端。十年来没有一天休息？这两个人拥有很好的天赋，但他们也像任何人一样努力工作。这两个你最好都需要。&lt;&#x2F;p&gt;
&lt;p&gt;这似乎很明显，但在实践中我们发现并不是这样。在天赋和努力工作之间存在着一种微弱的对立。它部分来自于文化，部分源于牛人比较罕见。如果很好的天赋和很强的驱动力都是罕见的，那么拥有两者的人就是罕见的平方。你遇到的大多数人，如果一个人很有天赋，另一个大概率就会比较少。但是，如果你想成为一个杰出的人，就需要这两样东西。由于你无法真正改变你的天赋，你能做的，就只剩下努力工作了。&lt;&#x2F;p&gt;
&lt;p&gt;如果你有明确的、外部设置的目标，就像在学校那样，那么努力工作是很直接的一件事。这其中有一些技巧：你必须学会不欺骗自己，不拖延时间（这也是一种欺骗自己的形式），不分心，遇到阻碍时不放弃。但这种程度的自律似乎主要是针对年轻人。&lt;&#x2F;p&gt;
&lt;p&gt;我从小学到的是如何朝着既没有明确定义也没有外部强加的目标努力。如果想做出不错的成绩，你可能必须同时学会这两点。&lt;&#x2F;p&gt;
&lt;p&gt;其中最基本的要求是觉得你应该工作，不需要任何人告诉你。现在，当我不努力工作时，警钟就会响起。我不确定是否有进展，但当我不努力时，我可以确定没有进展，这感觉很不好。&lt;&#x2F;p&gt;
&lt;p&gt;像大多数小孩子一样，我很享受学习或完成新事情时的成就感。随着年龄的增长，当我没有取得任何成就时，这种感觉就演变成了一种厌恶感。我印象很深刻，在我 13 岁时就不再看电视了。&lt;&#x2F;p&gt;
&lt;p&gt;我与几个人交谈过，他们差不多都是在这个年龄段开始认真对待工作。我问帕特里克-科里森，他是什么时候开始觉得讨厌无所事事的感觉的，他说：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;大约是在 13 或 14 岁。我清晰地记得我坐在起居室里，盯着外面，想知道为什么就这么浪费自己的暑假。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;也许在青春期有什么变化？&lt;&#x2F;p&gt;
&lt;p&gt;奇怪的是，认真工作的最大障碍可能来自学校，它使工作（他们所谓的工作）看起来很无聊，毫无意义。我们必须先了解什么是真正的工作，才能全心全意地渴望去做。这需要一段时间，因为即使在大学里，很多工作也是毫无意义的；甚至整个部门都是毫无意义的。但是，当我了解到真正工作的形态时，我发现我对工作的渴望与之契合，就好像它们是为彼此而生的。&lt;&#x2F;p&gt;
&lt;p&gt;我想大多数人需要先了解什么是工作，然后才能爱上它。哈代在《一个数学家的辩白》中论述了这一点。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;我不记得我小时候对数学有什么热情，我对数学家这个职业有过一些想法，但也认为这只是一份工作而已。我对数学的看法就是考试和奖学金：我想打败其他孩子，而我可以轻松地做到这点。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;他直到大学，读了乔丹的《分析课》 (Cauchy’s Cours d’analyse)后，才知道数学的真正含义，。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;我永远不会忘记我在阅读那本了不起的著作时的惊喜，它是我们这一代许多数学家的启蒙书，我在阅读它时第一次知道了数学的真正含义。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;为了理解什么是真正的工作，你需要甄别两种「假工作」。一种是哈代在学校遇到的那种。当课题被改编为教给孩子们时，它们就被扭曲了，常常被扭曲到与实际工作完全不同。另一种是某些类型的工作所固有的。有些类型的工作本质上是假的，或者充其量只是忙碌的工作。&lt;&#x2F;p&gt;
&lt;p&gt;真正的工作都有种共性，但也是一个模糊的标准，而且故意模糊的，因为它必须涵盖很多不同的类型。&lt;&#x2F;p&gt;
&lt;p&gt;一旦你知道真正工作的样子，你就必须学会每天花多少小时来做。这不是简单地在每个清醒的时间工作就行，因为在许多种工作中会有一个临界点，超过这个点，结果的质量就会开始下降。&lt;&#x2F;p&gt;
&lt;p&gt;这个限度因工作类型和个人而异。我做过几种不同类型的工作，每种工作的极限都不一样。我对较难的写作或编程类型的极限是每天约 5 小时。而当我在经营一家创业公司时，我可以一直工作。至少在我做的那三年里是这样；如果要坚持得更久，可能需要偶尔休假。&lt;&#x2F;p&gt;
&lt;p&gt;找到极限的唯一方法就是跨越它。培养对你所做的工作质量的敏感性，然后你就会注意到它是否因为你工作得太辛苦而下降了。诚实在这里至关重要，它包括两个方面：你必须注意到你什么时候在偷懒，但也要注意到你什么时候工作太辛苦。如果你认为工作太辛苦有什么值得骄傲的地方，请把这个想法去掉。你不仅会有更糟糕的结果，还可能是在对别人，或者对自己炫耀。&lt;&#x2F;p&gt;
&lt;p&gt;找到努力工作的极限是一个持续不断的过程。工作的难度和你的能力都会因时而异，所以你需要不断判断你的努力程度和你的表现。&lt;&#x2F;p&gt;
&lt;p&gt;不过，努力工作并不意味着不断逼迫自己去工作。可能有一些人是这样的，但我的经验是，我只有在开始一个项目或遇到某个问题时，才会偶尔逼迫自己。那时候我就可能产生拖延症了。但是一旦我开始行动，往往会持续下去。&lt;&#x2F;p&gt;
&lt;p&gt;让我坚持下去的动力，取决于工作的类型。当我在 Viaweb 工作时，我被对失败的恐惧所驱动。那时我几乎没有拖延，因为总是有一些事情需要做，如果我可以通过做这些事情把我和竞争者之间拉开更多的距离，为什么还要等呢？而现在驱动我写文章的，是那些缺陷。在两篇文章之间，我纠结了好几天。但一旦我开始决定写某一篇，我就不必逼自己了，因为总有一些错误或遗漏会驱动我。&lt;&#x2F;p&gt;
&lt;p&gt;我确实会努力关注重要的议题。许多问题都有一个坚硬的核心，边缘是一些比较容易的东西。努力工作意味着在你能做到的范围内瞄准核心。有些时候可能做不到；有些时候，你只能做一些比较容易的、边缘的事情。但你应该总是尽可能地接近中心而不是停滞不前。&lt;&#x2F;p&gt;
&lt;p&gt;「如何处理你的生活」这一更大的问题是这些硬核问题中的一个。中心有重要的问题，这些问题往往很困难，而边缘的问题则不太重要，比较容易。因此，除了在处理具体问题时涉及的小的、日常的调整外，你偶尔也要对「做哪种类型的工作」做出大的调整。而规则是相同的：努力工作意味着瞄准中心--瞄准对你来说最重要的问题。&lt;&#x2F;p&gt;
&lt;p&gt;无论是一般情况还是在特定领域内，关于哪些问题是最重要的共识往往是错误的。如果你不同意它，而你又觉得自己是对的，这可能是一个好机会。&lt;&#x2F;p&gt;
&lt;p&gt;宏伟的工作通常会更难，但也不应该把困难作为决定做什么的唯一参考。如果你发现某些工作类型对你来说比其他人更容易，无论是因为你碰巧拥有的能力，还是因为找到了一些新的方法，或者仅仅是因为你对它更感兴趣，都可以在这方面下功夫。&lt;&#x2F;p&gt;
&lt;p&gt;除了了解实际工作之外，你还需要弄清楚你适合哪种工作。这意味着要弄清楚你的天赋与哪种工作最匹配；但并不意味着如果你身高 7 英尺，你就必须打篮球。你适合做什么，不仅取决于你的才能，也许更取决于你的兴趣。对某一主题的浓厚兴趣会让人更努力地工作。&lt;&#x2F;p&gt;
&lt;p&gt;发现你的兴趣可能比发现你的才能更难。天赋的类型比兴趣少，往往在童年时就开始显现，而兴趣是一种微妙的东西，可能要到 20 多岁，甚至更晚才会被挖掘出来。此外，还会有一些错误信息需要学会甄别：你是真的对 X 感兴趣，还是因为你会赚很多钱，或者因为其他人会对你印象深刻，或者因为你的父母希望你这样做，所以你想在这方面努力？&lt;&#x2F;p&gt;
&lt;p&gt;要弄清楚该从事什么工作，其难度因人而异，差别很大。还是个孩子的时候，你觉得每个人都有自己的使命，他们所要做的就是弄清楚它是什么。电影里是这样的，给孩子们看的故事书里也是这样的，有时现实生活中也是如此。有些人在小时候就想好了要做什么，然后就去做，比如莫扎特。但其他人，如牛顿，则不安分地从一种工作转向另一种。也许回过头来，我们可以确定其中一项是他们的使命--我们可以希望牛顿在数学和物理学上花更多的时间，而在炼金术和神学上花更少的时间--但这就有点事后诸葛亮的意思了。&lt;&#x2F;p&gt;
&lt;p&gt;因此，虽然有些人的生活快速收敛（知道要做什么，并去做），但也会有一些人的生活从未收敛。对这些人来说，弄清楚要做什么工作与其说是努力工作的前奏，不如说是努力工作的一部分。对这些人来说，我前面描述的过程还有第三个组成部分：在衡量你工作的努力程度和你做得如何的同时，你必须考虑你是否应该继续在这个领域工作，还是转到另一个领域。如果你努力工作，但没有得到足够好的结果，你就应该换。这样表述听起来很简单，但实际上却很难。你不应该在第一天就放弃，只因为你努力工作却没有任何进展。你需要给自己一些时间，让自己有所作为。但是有多少时间呢？如果原本进展顺利的工作不再顺利，你又该怎么办？那时你会给自己多少时间？&lt;&#x2F;p&gt;
&lt;p&gt;什么样的结果才算好？这确实很难决定。如果你正在探索一个很少有人涉足的领域，你甚至可能不知道好的结果是什么样子。历史上有很多误判了他们所做工作的重要性的例子。&lt;&#x2F;p&gt;
&lt;p&gt;检验是否值得从事某项工作的最佳标准是你是否觉得它有趣。这听起来可能是一个危险的主观衡量标准，但它可能是你要得到的最准确的标准。你是从事这项工作的人。谁比你更有资格判断它是否重要，还有什么比它是否有趣更能体现它的重要性呢？&lt;&#x2F;p&gt;
&lt;p&gt;不过，要使这个测试发挥作用，你必须对自己诚实。事实上，这是整个努力工作问题最引人注目的地方：在每一点上都取决于对自己的诚实。&lt;&#x2F;p&gt;
&lt;p&gt;努力工作不仅仅是每天工作到 11 点。它是一个复杂的、动态的系统，必须在每个点上调整得恰到好处。你必须了解实际工作的样子，清楚地看到你最适合做哪种工作，尽可能地接近它的真正核心，在每个时刻准确判断你的能力和你的表现，并在不损害结果质量的情况下每天投入尽可能多的时间。这个网络太复杂了。但是，如果你始终诚实，目光清晰，它就会自动呈现出最佳形状，你就会以一种很少有人能做到的方式取得成效。&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>The Center of Why</title>
            <pubDate>Tue, 04 Apr 2017 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/the-center-of-why/</link>
            <guid>https://limboy.me/posts/the-center-of-why/</guid>
            <description>&lt;p&gt;这是 Alan Kay 在 04 年写的一篇长文。可能有部分同学对 Alan Kay 不是很熟悉，先做一个简单介绍：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;艾伦·凯（Alan Kay）是近当代计算机革命之先驱，他有一句广为人知的名言：预测未来的最好的办法就是创造未来。&lt;&#x2F;p&gt;
&lt;p&gt;三岁就能阅读，五岁便会自学，等到上小学的时候，已经读了上百本书。到现在（77 岁），已经读了大约 20,000 本书，有一份&lt;a href=&quot;http:&#x2F;&#x2F;www.squeakland.org&#x2F;resources&#x2F;books&#x2F;readingList.jsp&quot;&gt;推荐阅读的书单&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;京都奖（号称日本的诺贝尔奖）和图灵奖获得者。Smalltalk 面向对象编程环境语言的发明人之一，也是面向对象编程思想的创始人之一，同时，他还是笔记本电脑最早的构想者和现代图形用户介面 GUI 的建筑师。也最早提出了 Dynabook（后来经过演变就变成了我们今天的笔记本电脑）的概念。当年就乔布斯就是在看到了 PARC 里的这些作品后，下定决心往 GUI 方向发力。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;老爷子对儿童教育非常重视，这也直接激发了他发明新的编程语言和图形视窗系统，希望每个孩子都能有一个笔记本大小的电脑，在软件里建造和模拟他们自己的真实世界模型，并让他们实验、修补、评价和观察这些模型的行为特征。不过用他自己的话来说，他对儿童教育并没有特别大的热情，对于培养优秀的成年人兴趣更大。&lt;&#x2F;p&gt;
&lt;p&gt;现在 Alan Kay 会参与到 YC 新创建的 HARC (Human Advancement Research Community) 项目中，这个项目的使命是通过发明新技术，传播知识和想法，让人们可以看得更远，理解地更加深刻。跟当年的 PARC 有点像，后者由于辉煌时期的原班人马已基本走光，虽然现在独立了出来，也很难再现当年的风采了。&lt;&#x2F;p&gt;
&lt;p&gt;忘了怎么接触到这篇文章了，看完收获不少，不敢独享。这里做了精简的翻译，感兴趣的同学还是直接看英文原文吧，内容会丰富不少。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;geng-duo-de-shu&quot;&gt;更多的书&lt;&#x2F;h3&gt;
&lt;p&gt;在上学之前就读了很多书，发现对同一个观念往往会有很多不同的解说。「there was more than one point of view」，所以不要急着接受某个观点。&lt;&#x2F;p&gt;
&lt;p&gt;然后上学后，发现学校里每个领域只有一本书，也就是老师手里的那本权威书。结果由于准备工作做得过于充分，经常会提各种问题，比如「我在其他书上看到过不是这样的，它也可以是这样···」，自然就被打入冷宫，他倒也不埋怨，反正要学什么看书就行了，不太需要老师。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;9-sui-yu-dao-liao-di-yi-ge-hao-lao-shi&quot;&gt;9 岁遇到了第一个好老师&lt;&#x2F;h3&gt;
&lt;p&gt;在这个老师（看起来应该是个物理老师）的课堂里的教室后面放着一张桌子，上面放着各种工具、线、电池、书，她也不说这些是拿来做啥的。好奇的 Kay 拿来了干电池、电线、钉子、回形针做起了电磁感应实验。&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;1.png&quot;
        width=&quot;406&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在成功地吸起回形针后，Kay 同学很兴奋地叫了出来，然后惊讶地发现老师居然没有骂他，而是问他怎么做到的？书里还提到了什么？当他表示下一个要做电报机时，询问了有没有感兴趣的同学一起来做，然后下午找一段时间一起来搞（20%的 Side Project 时间）。&lt;&#x2F;p&gt;
&lt;p&gt;后来有一半以上的同学都参与到了项目中，而且越来越早地来到学校，这样就可以花更多的时间做项目。&lt;&#x2F;p&gt;
&lt;p&gt;也是这份经历让 Kay 意识到应该如何进行基础教育：让孩子们参与到感兴趣的项目中，同时融合数学、科学、艺术在其中。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;They need to go through many of the same processes of discovery in order to make new ideas their own.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;the-center-of-why-is-art&quot;&gt;The Center of “Why?” is Art&lt;&#x2F;h3&gt;
&lt;p&gt;我们创作的所有事物都可以被称作艺术。科学和技术也都是艺术，只是形式不一样。&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;2.png&quot;
        width=&quot;828&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;「科学的艺术」就是找到不被愚弄的方式，让不可见变得可见，创建最能反映实际情况的理论。&lt;&#x2F;p&gt;
&lt;p&gt;科学不容易被直观地表现，因为只能借助数学、物理或者计算机等非大自然原产物来揭示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ke-xue-jie-yu-bei-hou-de-zhen-xiang-he-miao-shu-bei-hou-de-zhen-xiang-zhi-jian&quot;&gt;科学介于「背后的真相」和「描述背后的真相」之间&lt;&#x2F;h3&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;3.jpg&quot;
        width=&quot;862&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这两幅地图都有细节，且精心绘制。不同的是右边是真实的地图（印度），而左边是指环王里的地图。很难通过肉眼来区分哪个是现实中的地图，需要借助额外的手段，也就是「科学的艺术」。&lt;&#x2F;p&gt;
&lt;p&gt;以重力为例，它就像一只小兔子，在幕布上的投影就是我们在地球上的感知和量测。我们可以构建一个模型，同样能形成兔子投影，以牛顿的万有引力理论为例，他通过数学来阐述模型，但如果仔细观察会发现真实的兔子投影尾部是一个小圆球，而牛顿的模型尾部是粗长手臂的投影。&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;4.png&quot;
        width=&quot;1252&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这个「手臂投影」需要花一点时间去发现，比如水星的公转轨道不符合牛顿定律，所以牛顿的万有引力模型并不完美。（为了把小兔子尾部的小圆球补上，爱因斯坦采用了跟牛顿截然不同的方式）&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;5.png&quot;
        width=&quot;341&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在最近的几百年里，通过科学，我们发现直觉往往是不准的：我们在不停地愚弄自己。所以尽量避免通过感觉来做判断和行动，多思考一下，不然很容易导致错误的结果。&lt;&#x2F;p&gt;
&lt;p&gt;科学让不可见变得更加可见，而我们对于自己却往往视而不见。很多人生活在自己的故事和社会里，对于自身、环境甚至地球都很危险。所以教育的职责除了教授知识、技能之外，更重要的是传授「让不可见变得可见」的能力。&lt;&#x2F;p&gt;
&lt;p&gt;只有意识到自己看不清，看不全才会学着去发现。教育就是帮助人们认识到自己视野的局限性，同时教会他们如何看得更清楚一些。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-xue-zhi-mei&quot;&gt;数学之美&lt;&#x2F;h3&gt;
&lt;p&gt;数学概念往往很难向一个普通人解释清楚，但有一些却可以阐释得很明了。比如 2500 年前对勾股定理的证明（想要了解更多的可以参考&lt;a href=&quot;http:&#x2F;&#x2F;math.stackexchange.com&#x2F;questions&#x2F;675522&#x2F;whats-the-intuition-behind-pythagoras-theorem&quot;&gt;这个帖子&lt;&#x2F;a&gt; ）&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;6.png&quot;
        width=&quot;400&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;证明过程直观且简单，很美。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ji-suan-zhi-mei&quot;&gt;计算之美&lt;&#x2F;h3&gt;
&lt;p&gt;计算难免会涉及到数学，在看到 John McCarthy 的 LISP 语言后，Kay 觉得这门强大又优雅的语言充满了魅力，看待事物的角度奇特又深刻，就像麦克斯韦的电磁方程。对他之后的想法产生了很多影响。&lt;&#x2F;p&gt;
&lt;p&gt;在大学时看到了图形编程系统（Sketchpad），愈发觉得计算机可以做的事情会很多且很不一样。后来又接触到了 Simula 语言，同时结合自己的数学和微生物背景（没错，他大学的专业之一是微生物学），他有了这么个想法：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;我假定未来理想的计算机能够具备生物组织一样的功能，每个‘细胞’能够独立运作，也能与其他功能一起完成复杂的目标。‘细胞’能够相互重组，以解决问题或者完成功能。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;围绕着这个想法开始设计系统，进行各种试验，当别人问起他在干什么时，他回答：面向对象编程。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;doug-engelbart-he-ta-de-jiao-hu-shi-jie&quot;&gt;Doug Engelbart 和他的交互世界&lt;&#x2F;h3&gt;
&lt;p&gt;Doug Engelbart 创建了 NLS 系统，这个系统包含了导航控制器（鼠标前身）、超文本、图形、命令行输入等，描述了一个可交互的计算机应该是怎样的。&lt;&#x2F;p&gt;
&lt;p&gt;导师介绍了 Ed Cheadle 给 Kay 认识，这位同学试图把计算变得更小，小到可以放在桌上，同时可以交互。然后两人一拍即合，开始研发 FLEX Machine，目标是个人计算机。它被构思成长这样：&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;7.png&quot;
        width=&quot;600&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当时是 1968 年，距离 Macintosh 1 发布还有 16 年。&lt;&#x2F;p&gt;
&lt;p&gt;在探索可交互计算机的用途时，遇到了 Seymour Papert 和 LOGO 语言，发现可以通过计算机向儿童更直观地阐述抽象概念，比如数学。Kay 被这个想法震撼到了，觉得这是计算机的正途。于是开始构思类似 Flex 的机器，不过面向儿童，名字叫 Dynabook。把编程语言与游戏结合来表达数学之美。所以计算机除了作为工具，还可以作为展示的平台。（可惜这个本子最终没有做出来，不过也算是笔记本的先驱了）&lt;&#x2F;p&gt;
&lt;p&gt;这就需要一门新的面向对象编程语言，为了向人证明只需半页就能将当时世界上最强大的编程语言描述清楚，两个礼拜之后，Kay 做出了 Smalltalk 的 kernel。一个月之后和同事一起研发出了可以正常工作的高级、简单又强大的面向对象编程语言。&lt;&#x2F;p&gt;
&lt;p&gt;几个月之后，Dynabook 的过渡态产物 Alto 诞生了。1975 年，已经有上千台 Alto 计算机在学校中被使用了。（第一代苹果电脑正式发行在 9 年后）&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;8.png&quot;
        width=&quot;491&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;之后的几年时间里，PARC 的研究人员各自钻研自己的领域，并且取得了不错的结果，对于推动计算机及互联网功不可没。（这些重要的工作主要是由 25 个科学家完成的）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hai-zi-men-neng-zuo-xie-shi-yao&quot;&gt;孩子们能做些什么？&lt;&#x2F;h3&gt;
&lt;p&gt;孩子们是天生的艺术家，如果要教育他们，要保护好他们的艺术思维，先让他们对某个想法产生兴趣。&lt;&#x2F;p&gt;
&lt;p&gt;比如可以让他们结对组成小项目组（10 人左右），设计汽车，并通过调整参数和一些简单的编程，让这辆车按自己的意愿跑起来。&lt;&#x2F;p&gt;

&lt;p  style=&quot;text-align:center&quot; &gt;&lt;img src=&quot;&amp;#x2F;posts&amp;#x2F;the-center-of-why&amp;#x2F;9.png&quot;
        width=&quot;1242&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在这个过程中可以传授类似「加速度」这样的知识点。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mo-ni-fu-za-mo-xing&quot;&gt;模拟复杂模型&lt;&#x2F;h3&gt;
&lt;p&gt;可以通过图形化编程，让计算机来模拟复杂的系统，比如传染病或者谣言。也可以用来模拟重力或弹性。甚至对现实中的桥梁建模，通过模型来模拟各种极端场景，以此来验证桥梁的可靠性，避免完工后出现各种故障。&lt;&#x2F;p&gt;
&lt;p&gt;「要了解世界，必须构建世界」，通过计算机可以对真实世界进行建模、调整、优化、实验，可以更好地表达自己的想法，这不也是一件很 Romantic 和 Art 的事情么？&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>Github的扁平化管理与创新</title>
            <pubDate>Thu, 30 Jan 2014 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/github-lean-management-strategy/</link>
            <guid>https://limboy.me/posts/github-lean-management-strategy/</guid>
            <description>&lt;p&gt;fastcolabs 带来的&lt;a href=&quot;http:&#x2F;&#x2F;www.fastcolabs.com&#x2F;3020181&#x2F;open-company&#x2F;inside-githubs-super-lean-management-strategy-and-how-it-drives-innovation&quot;&gt;Github 专访&lt;&#x2F;a&gt;，里面谈到了很多 Github 内部的管理、沟通、创新，看完之后对这家公司又多了几分了解和敬仰，其中的一些理念对于「传统」的创业公司来说是很难相信和接受的。原文很长，这里简单的摘录几段。&lt;&#x2F;p&gt;
&lt;p&gt;Github 在公司内部实践「开源合作」的精神，员工可以自愿加入自己感兴趣的项目，而不是接受上面的安排。也正是这样的环境和氛围更容易吸引有创造力、有能力、自学能力强的人才。&lt;&#x2F;p&gt;
&lt;p&gt;「开放式安排（Open Allocation）」的关键是沟通，尤其是一个开放的、好用的、高效的沟通工具。既然任何人都可以加入到某个项目中，那么这个项目的素材和文档就得准备好，不然新人进来还要摸索半天，会打消热情。&lt;&#x2F;p&gt;
&lt;p&gt;「任务」来自上头，怎样找到合适的方法去执行就看各个「自组织」Team 自己了。&lt;&#x2F;p&gt;
&lt;p&gt;好的沟通也容易产生新的业务，因为有了良好的沟通平台，所以新项目很容易被上头知道，上头可以根据这些新项目来调整方向，同时再分发到沟通平台，这样大家就到知道了。&lt;&#x2F;p&gt;
&lt;p&gt;有了良好的沟通平台，小组负责人就知道公司前进的方向，其他人也都知道为什么要向那个方向迈进，因为上头会跟你解释，你也可以参与讨论。&lt;&#x2F;p&gt;
&lt;p&gt;让最接近问题的人拍板。而不是上头委派下面的员工完成指定的任务，而是认为最接近问题的人最了解这个问题，因此也最拥有话语权。&lt;&#x2F;p&gt;
&lt;p&gt;上头制定对公司来说最重要的战略，Team 也如此。在知道最重要的事情后，小组成员可以自行选择其中自己最感兴趣的来做。&lt;&#x2F;p&gt;
&lt;p&gt;有些公司有 20%的时间来做自己感兴趣的项目，对于 Github 来说，几乎是 100%的时间。如果没有太感兴趣的，那就找到兴趣点和成就感。&lt;&#x2F;p&gt;
&lt;p&gt;正是因为 Github 如此自由的环境，所以对新员工的要求也会很高，必须是自驱动，对自己所从事的工作充满热情。每个人都在通过某种方式做着对公司有益的事情。&lt;&#x2F;p&gt;
&lt;p&gt;新项目往往都是从「做着玩」开始的，然后看看能不能说服、吸引其他人来一起维护。&lt;&#x2F;p&gt;
&lt;p&gt;让员工一直在做最让他们兴奋的事情，这就是创新之源。&lt;&#x2F;p&gt;
&lt;p&gt;70%的员工都是远程办公，所以聊天室反倒成了真正的办公室。大约有 70-80 个聊天室，对哪个项目感兴趣，进去就行。&lt;&#x2F;p&gt;
&lt;p&gt;还有很多很多，英语水平有限，只能寥寥翻译几句，英语过关的，不妨&lt;a href=&quot;http:&#x2F;&#x2F;www.fastcolabs.com&#x2F;3020181&#x2F;open-company&#x2F;inside-githubs-super-lean-management-strategy-and-how-it-drives-innovation&quot;&gt;看一下全文&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)KVO的内部实现</title>
            <pubDate>Thu, 15 Aug 2013 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/internal-implementation-of-kvo/</link>
            <guid>https://limboy.me/posts/internal-implementation-of-kvo/</guid>
            <description>&lt;p&gt;09 年的&lt;a href=&quot;http:&#x2F;&#x2F;www.mikeash.com&#x2F;pyblog&#x2F;friday-qa-2009-01-23.html&quot;&gt;一篇文章&lt;&#x2F;a&gt;，比较深入地阐述了 KVO 的内部实现。&lt;&#x2F;p&gt;
&lt;p&gt;KVO 是实现 Cocoa Bindings 的基础，它提供了一种方法，当某个属性改变时，相应的 objects 会被通知到。在其他语言中，这种观察者模式通常需要单独实现，而在 Objective-C 中，通常无须增加额外代码即可使用。&lt;&#x2F;p&gt;
&lt;p&gt;###概览
这是怎么实现的呢？其实这都是通过 Objective-C 强大的运行时(runtime)实现的。当你第一次观察某个 object 时，runtime 会创建一个新的继承原先 class 的 subclass。在这个新的 class 中，它重写了所有被观察的 key，然后将 object 的&lt;code&gt;isa&lt;&#x2F;code&gt;指针指向新创建的 class（这个指针告诉 Objective-C 运行时某个 object 到底是哪种类型的 object）。所以 object 神奇地变成了新的子类的实例。&lt;&#x2F;p&gt;
&lt;p&gt;这些被重写的方法实现了如何通知观察者们。当改变一个 key 时，会触发&lt;code&gt;setKey&lt;&#x2F;code&gt;方法，但这个方法被重写了，并且在内部添加了发送通知机制。（当然也可以不走 setXXX 方法，比如直接修改 iVar，但不推荐这么做）。&lt;&#x2F;p&gt;
&lt;p&gt;有意思的是：苹果不希望这个机制暴露在外部。除了 setters，这个动态生成的子类同时也重写了&lt;code&gt;-class&lt;&#x2F;code&gt;方法，依旧返回原先的 class！如果不仔细看的话，被 KVO 过的 object 看起来和原先的 object 没什么两样。&lt;&#x2F;p&gt;
&lt;p&gt;###深入探究
下面来看看这些是如何实现的。我写了个程序来演示隐藏在 KVO 背后的机制。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; gcc -o kvoexplorer -framework Foundation kvoexplorer.m
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#import &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;lt;Foundation&#x2F;Foundation.h&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#import &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;lt;objc&#x2F;runtime.h&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@interface &lt;&#x2F;span&gt;&lt;span&gt;TestClass : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;NSObject
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; x;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; y;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; z;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@property int&lt;&#x2F;span&gt;&lt;span&gt; x;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@property int&lt;&#x2F;span&gt;&lt;span&gt; y;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@property int&lt;&#x2F;span&gt;&lt;span&gt; z;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@implementation &lt;&#x2F;span&gt;&lt;span&gt;TestClass
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@synthesize&lt;&#x2F;span&gt;&lt;span&gt; x, y, z;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSArray &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;ClassMethodNames&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;Class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSMutableArray &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;array &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSMutableArray &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;array&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt; methodCount &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;Method \&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;methodList &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_copyMethodList&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(c, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;methodCount)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt; i;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;(i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; methodCount; i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;[array &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;addObject: NSStringFromSelector(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;method_getName&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(methodList[i]))&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;free(methodList)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; array;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;PrintDescription&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;str &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;stringWithFormat:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;\n\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;NSObject class &lt;&#x2F;span&gt;&lt;span&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;\n\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;libobjc class &lt;&#x2F;span&gt;&lt;span&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;\n\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;implements methods &amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;name,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;obj,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_getName&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;([obj class]),
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_getName&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(obj-&amp;gt;isa),
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;ClassMethodNames&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(obj-&amp;gt;isa) componentsJoinedByString&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;printf(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, [str UTF8String])&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;argc&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt; \&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;**&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;argv&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSAutoreleasePool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[[TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;alloc&lt;&#x2F;span&gt;&lt;span&gt;] init];
&lt;&#x2F;span&gt;&lt;span&gt;TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[[TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;alloc&lt;&#x2F;span&gt;&lt;span&gt;] init];
&lt;&#x2F;span&gt;&lt;span&gt;TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;xy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[[TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;alloc&lt;&#x2F;span&gt;&lt;span&gt;] init];
&lt;&#x2F;span&gt;&lt;span&gt;TestClass \&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;control &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[[TestClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;alloc&lt;&#x2F;span&gt;&lt;span&gt;] init];
&lt;&#x2F;span&gt;&lt;span&gt;[x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;addObserver:x forKeyPath:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;x&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;options:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;context:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;[xy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;addObserver:xy forKeyPath:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;x&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;options:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;context:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;[y &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;addObserver:y forKeyPath:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;y&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;options:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;context:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;[xy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;addObserver:xy forKeyPath:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;y&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;options:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;context:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;PrintDescription&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;control&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, control)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;PrintDescription&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;x&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, x)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;PrintDescription&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;y&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, y)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;PrintDescription&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;xy&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, xy)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;printf(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;Using NSObject methods, normal setX: is &lt;&#x2F;span&gt;&lt;span&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;, overridden setX: is &lt;&#x2F;span&gt;&lt;span&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;[control methodForSelector:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(setX:)],
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;[x methodForSelector:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(setX:)])&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;printf(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;Using libobjc functions, normal setX: is &lt;&#x2F;span&gt;&lt;span&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;, overridden setX: is &lt;&#x2F;span&gt;&lt;span&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;method_getImplementation&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_getInstanceMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;object_getClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(control),
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(setX:))),
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;method_getImplementation&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_getInstanceMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;object_getClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(x),
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(setX:))))&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们从头到尾细细看来。&lt;&#x2F;p&gt;
&lt;p&gt;首先定义了一个&lt;code&gt;TestClass&lt;&#x2F;code&gt;的类，它有 3 个属性。&lt;&#x2F;p&gt;
&lt;p&gt;然后定义了一些方便调试的方法。&lt;code&gt;ClassMethodNames&lt;&#x2F;code&gt;使用 Objective-C 运行时方法来遍历一个 class，得到方法列表。注意，这些方法不包括父类的方法。&lt;code&gt;PrintDescription&lt;&#x2F;code&gt;打印 object 的所有信息，包括 class 信息（包括&lt;code&gt;-class&lt;&#x2F;code&gt;和通过运行时得到的 class），以及这个 class 实现的方法。&lt;&#x2F;p&gt;
&lt;p&gt;然后创建了 4 个&lt;code&gt;TestClass&lt;&#x2F;code&gt;实例，每一个都使用了不同的观察方式。&lt;code&gt;x&lt;&#x2F;code&gt;实例有一个观察者观察&lt;code&gt;x&lt;&#x2F;code&gt;key，&lt;code&gt;y&lt;&#x2F;code&gt;, &lt;code&gt;xy&lt;&#x2F;code&gt;也类似。为了做比较，&lt;code&gt;z&lt;&#x2F;code&gt;key 没有观察者。最后&lt;code&gt;control&lt;&#x2F;code&gt;实例没有任何观察者。&lt;&#x2F;p&gt;
&lt;p&gt;然后打印出 4 个 objects 的 description。&lt;&#x2F;p&gt;
&lt;p&gt;之后继续打印被重写的 setter 内存地址，以及未被重写的 setter 的内存地址做比较。这里做了两次，是因为&lt;code&gt;-methodForSelector:&lt;&#x2F;code&gt;没能得到重写的方法。KVO 试图掩盖它实际上创建了一个新的 subclass 这个事实！但是使用运行时的方法就原形毕露了。&lt;&#x2F;p&gt;
&lt;p&gt;###运行代码
看看这段代码的输出&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span&gt;control&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;TestClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x104b20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSObject&lt;&#x2F;span&gt;&lt;span&gt; class TestClass
&lt;&#x2F;span&gt;&lt;span&gt;libobjc class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;TestClass
&lt;&#x2F;span&gt;&lt;span&gt;implements methods &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, x, setY&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, y, setZ&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, z&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;TestClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x103280&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSObject&lt;&#x2F;span&gt;&lt;span&gt; class TestClass
&lt;&#x2F;span&gt;&lt;span&gt;libobjc class NSKVONotifying_TestClass
&lt;&#x2F;span&gt;&lt;span&gt;implements methods &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;setY&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, class, dealloc, \_isKVOA&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;TestClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x104b00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSObject&lt;&#x2F;span&gt;&lt;span&gt; class TestClass
&lt;&#x2F;span&gt;&lt;span&gt;libobjc class NSKVONotifying_TestClass
&lt;&#x2F;span&gt;&lt;span&gt;implements methods &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;setY&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, class, dealloc, \_isKVOA&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;xy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;TestClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x104b10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSObject&lt;&#x2F;span&gt;&lt;span&gt; class TestClass
&lt;&#x2F;span&gt;&lt;span&gt;libobjc class NSKVONotifying_TestClass
&lt;&#x2F;span&gt;&lt;span&gt;implements methods &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;setY&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;, class, dealloc, \_isKVOA&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;Using &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSObject&lt;&#x2F;span&gt;&lt;span&gt; methods, normal setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x195e&lt;&#x2F;span&gt;&lt;span&gt;, overridden setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x195e
&lt;&#x2F;span&gt;&lt;span&gt;Using libobjc functions, normal setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x195e&lt;&#x2F;span&gt;&lt;span&gt;, overridden setX&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x96a1a550
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;首先，它输出了&lt;code&gt;control&lt;&#x2F;code&gt;object，没有任何问题，它的 class 是&lt;code&gt;TestClass&lt;&#x2F;code&gt;，并且实现了 6 个 set&#x2F;get 方法。&lt;&#x2F;p&gt;
&lt;p&gt;然后是 3 个被观察的 objects。注意&lt;code&gt;-class&lt;&#x2F;code&gt;仍然显示的是&lt;code&gt;TestClass&lt;&#x2F;code&gt;，使用&lt;code&gt;object_getClass&lt;&#x2F;code&gt;显示了这个 object 的真面目：它是&lt;code&gt;NSKVONotifying_TestClass&lt;&#x2F;code&gt;的一个实例。这个&lt;code&gt;NSKVONotifying_TestClass&lt;&#x2F;code&gt;就是动态生成的 subclass！&lt;&#x2F;p&gt;
&lt;p&gt;注意，它是如何实现这两个被观察的 setters 的。你会发现，它很聪明，没有重写&lt;code&gt;-setZ:&lt;&#x2F;code&gt;，虽然它也是个 setter，因为它没有被观察。同时注意到，3 个实例对应的是同一个 class，也就是说两个 setters 都被重写了，尽管其中的两个实例只观察了一个属性。这会带来一点效率上的问题，因为即使没有被观察的 property 也会走被重写的 setter，但苹果显然觉得这比分开生成动态的 subclass 更好，我也觉得这是个正确的选择。&lt;&#x2F;p&gt;
&lt;p&gt;你会看到 3 个其他的方法。有之前提到过的被重写的&lt;code&gt;-class&lt;&#x2F;code&gt;方法，假装自己还是原来的 class。还有&lt;code&gt;-dealloc&lt;&#x2F;code&gt;方法处理一些收尾工作。还有一个&lt;code&gt;_isKVOA&lt;&#x2F;code&gt;方法，看起来像是一个私有方法。&lt;&#x2F;p&gt;
&lt;p&gt;接下来，我们输出&lt;code&gt;-setX:&lt;&#x2F;code&gt;的实现。使用&lt;code&gt;-methodForSelector:&lt;&#x2F;code&gt;返回的是相同的值。因为&lt;code&gt;-setX:&lt;&#x2F;code&gt;已经在子类被重写了，这也就意味着&lt;code&gt;methodForSelector:&lt;&#x2F;code&gt;在内部实现中使用了&lt;code&gt;-class&lt;&#x2F;code&gt;，于是得到了错误的结果。&lt;&#x2F;p&gt;
&lt;p&gt;最后我们通过运行时得到了不同的输出结果。&lt;&#x2F;p&gt;
&lt;p&gt;作为一个优秀的探索者，我们进入 debugger 来看看这第二个方法的实现到底是怎样的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span&gt;(gdb) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;print &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;IMP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x96a1a550
&lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;IMP&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x96a1a550 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;\_NSSetIntValueAndNotify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;看起来是一个内部方法，对&lt;code&gt;Foundation&lt;&#x2F;code&gt;使用&lt;code&gt;nm -a&lt;&#x2F;code&gt;得到一个完整的私有方法列表：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;df80&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetBoolValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;000&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;a0480&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetCharValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e120&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetDoubleValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e1&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;f0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetFloatValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;000e3550&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetIntValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e390&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetLongLongValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e2&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;c0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetLongValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;000&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;89df0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetObjectValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e6&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;f0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetPointValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e7&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;d0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetRangeValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e8&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;b0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetRectValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e550&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetShortValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;000&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;8ab20&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetSizeValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e050&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetUnsignedCharValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;000&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;9fcd0&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetUnsignedIntValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e470&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetUnsignedLongLongValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;000&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#c82829;&quot;&gt;9fc00&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetUnsignedLongValueAndNotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0013e620&lt;&#x2F;span&gt;&lt;span&gt; t __NSSetUnsignedShortValueAndNotify
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个列表也能发现一些有趣的东西。比如苹果为每一种 primitive type 都写了对应的实现。Objective-C 的 object 会用到的其实只有&lt;code&gt;__NSSetObjectValueAndNotify&lt;&#x2F;code&gt;，但需要一整套来对应剩下的，而且看起来也没有实现完全，比如&lt;code&gt;long dobule&lt;&#x2F;code&gt;或&lt;code&gt;_Bool&lt;&#x2F;code&gt;都没有。甚至没有为通用指针类型(generic pointer type)提供方法。所以，不在这个方法列表里的属性其实是不支持 KVO 的。&lt;&#x2F;p&gt;
&lt;p&gt;KVO 是一个很强大的工具，有时候过于强大了，尤其是有了自动触发通知机制。现在你知道它内部是怎么实现的了，这些知识或许能帮助你更好地使用它，或在它出错时更方便调试。&lt;&#x2F;p&gt;
&lt;p&gt;如果你打算使用 KVO，或许可以看一下我的另一篇文章&lt;a href=&quot;http:&#x2F;&#x2F;www.mikeash.com&#x2F;?page=pyblog&#x2F;key-value-observing-done-right.html&quot;&gt;Key-Value Observing Done Right&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)Objective-C的动态特性</title>
            <pubDate>Sat, 03 Aug 2013 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/dynamic-tips-and-tricks-with-objective-c/</link>
            <guid>https://limboy.me/posts/dynamic-tips-and-tricks-with-objective-c/</guid>
            <description>&lt;p&gt;这是一篇译文，原文&lt;a href=&quot;http:&#x2F;&#x2F;pilky.me&#x2F;view&#x2F;21&quot;&gt;在此&lt;&#x2F;a&gt;，上一篇文章就是受这篇文章启发，这次干脆都翻译过来。&lt;&#x2F;p&gt;
&lt;p&gt;过去的几年中涌现了大量的 Objective-C 开发者。有些是从动态语言转过来的，比如 Ruby 或 Python，有些是从强类型语言转过来的，如 Java 或 C#，当然也有直接以 Objective-C 作为入门语言的。也就是说有很大一部分开发者都没有使用 Objective-C 太长时间。当你接触一门新语言时，更多地会关注基础知识，如语法和特性等。但通常有一些更高级的，更鲜为人知又有强大功能的特性等待你去开拓。&lt;&#x2F;p&gt;
&lt;p&gt;这篇文章主要是来领略下 Objective-C 的运行时(runtime)，同时解释是什么让 Objective-C 如此动态，然后感受下这些动态化的技术细节。希望这回让你对 Objective-C 和 Cocoa 是如何运行的有更好的了解。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-runtime&quot;&gt;The Runtime&lt;&#x2F;h2&gt;
&lt;p&gt;Objective-C 是一门简单的语言，95%是 C。只是在语言层面上加了些关键字和语法。真正让 Objective-C 如此强大的是它的运行时。它很小但却很强大。它的核心是消息分发。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;messages&quot;&gt;Messages&lt;&#x2F;h3&gt;
&lt;p&gt;如果你是从动态语言如 Ruby 或 Python 转过来的，可能知道什么是消息，可以直接跳过进入下一节。那些从其他语言转过来的，继续看。&lt;&#x2F;p&gt;
&lt;p&gt;执行一个方法，有些语言，编译器会执行一些额外的优化和错误检查，因为调用关系很直接也很明显。但对于消息分发来说，就不那么明显了。在发消息前不必知道某个对象是否能够处理消息。你把消息发给它，它可能会处理，也可能转给其他的 Object 来处理。一个消息不必对应一个方法，一个对象可能实现一个方法来处理多条消息。&lt;&#x2F;p&gt;
&lt;p&gt;在 Objective-C 中，消息是通过&lt;code&gt;objc_msgSend()&lt;&#x2F;code&gt;这个 runtime 方法及相近的方法来实现的。这个方法需要一个 target，selector，还有一些参数。理论上来说，编译器只是把消息分发变成&lt;code&gt;objc_msgSend&lt;&#x2F;code&gt;来执行。比如下面这两行代码是等价的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span&gt;[array &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;insertObject:foo atIndex:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;objc_msgSend&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(array, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(insertObject:atIndex:), foo, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;objects-classes-metaclasses&quot;&gt;Objects, Classes, MetaClasses&lt;&#x2F;h3&gt;
&lt;p&gt;大多数面向对象的语言里有 classes 和 objects 的概念。Objects 通过 Classes 生成。但是在 Objective-C 中，classes 本身也是 objects(译者注：这点跟 python 很像)，也可以处理消息，这也是为什么会有类方法和实例方法。具体来说，Objective-C 中的 Object 是一个结构体(struct)，第一个成员是&lt;code&gt;isa&lt;&#x2F;code&gt;，指向自己的 class。这是在 objc&#x2F;objc.h 中定义的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;typedef struct&lt;&#x2F;span&gt;&lt;span&gt; objc_object {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;Class&lt;&#x2F;span&gt;&lt;span&gt; isa;
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;id;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;object 的 class 保存了方法列表，还有指向父类的指针。但 classes 也是 objects，也会有&lt;code&gt;isa&lt;&#x2F;code&gt;变量，那么它又指向哪儿呢？这里就引出了第三个类型: &lt;code&gt;metaclasses&lt;&#x2F;code&gt;。一个 metaclass 被指向 class，class 被指向 object。它保存了所有实现的方法列表，以及父类的 metaclass。如果想更清楚地了解 objects,classes 以及 metaclasses 是如何一起工作地，可以阅读&lt;a href=&quot;http:&#x2F;&#x2F;www.sealiesoftware.com&#x2F;blog&#x2F;archive&#x2F;2009&#x2F;04&#x2F;14&#x2F;objc_explain_Classes_and_metaclasses.html&quot;&gt;这篇文章&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;methods-selectors-and-imps&quot;&gt;Methods, Selectors and IMPs&lt;&#x2F;h3&gt;
&lt;p&gt;我们知道了运行时会发消息给对象。我们也知道一个对象的 class 保存了方法列表。那么这些消息是如何映射到方法的，这些方法又是如何被执行的呢？&lt;&#x2F;p&gt;
&lt;p&gt;第一个问题的答案很简单。class 的方法列表其实是一个字典，key 为 selectors，IMPs 为 value。一个 IMP 是指向方法在内存中的实现。很重要的一点是，selector 和 IMP 之间的关系是在运行时才决定的，而不是编译时。这样我们就能玩出些花样。&lt;&#x2F;p&gt;
&lt;p&gt;IMP 通常是指向方法的指针，第一个参数是 self，类型为 id，第二个参数是_cmd，类型为 SEL，余下的是方法的参数。这也是&lt;code&gt;self&lt;&#x2F;code&gt;和&lt;code&gt;_cmd&lt;&#x2F;code&gt;被定义的地方。下面演示了 Method 和 IMP&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;)doSomethingWithInt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;)aInt{}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;doSomethingWithInt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;SEL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_cmd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; aInt)&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;qi-ta-yun-xing-shi-de-fang-fa&quot;&gt;其他运行时的方法&lt;&#x2F;h3&gt;
&lt;p&gt;现在我们知道了 objects,classes,selectors,IMPs 以及消息分发，那么运行时到底能做什么呢？主要有两个作用：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;创建、修改、自省 classes 和 objects&lt;&#x2F;li&gt;
&lt;li&gt;消息分发&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;之前已经提过消息分发，不过这只是一小部分功能。所有的运行时方法都有特定的前缀。下面是一些有意思的方法：&lt;&#x2F;p&gt;
&lt;h4 id=&quot;class&quot;&gt;class&lt;&#x2F;h4&gt;
&lt;p&gt;class 开头的方法是用来修改和自省 classes。方法如&lt;code&gt;class_addIvar&lt;&#x2F;code&gt;, &lt;code&gt;class_addMethod&lt;&#x2F;code&gt;, &lt;code&gt;class_addProperty&lt;&#x2F;code&gt;和&lt;code&gt;class_addProtocol&lt;&#x2F;code&gt;允许重建 classes。&lt;code&gt;class_copyIvarList&lt;&#x2F;code&gt;, &lt;code&gt;class_copyMethodList&lt;&#x2F;code&gt;, &lt;code&gt;class_copyProtocolList&lt;&#x2F;code&gt;和&lt;code&gt;class_copyPropertyList&lt;&#x2F;code&gt;能拿到一个 class 的所有内容。而&lt;code&gt;class_getClassMethod&lt;&#x2F;code&gt;, &lt;code&gt;class_getClassVariable&lt;&#x2F;code&gt;, &lt;code&gt;class_getInstanceMethod&lt;&#x2F;code&gt;, &lt;code&gt;class_getInstanceVariable&lt;&#x2F;code&gt;, &lt;code&gt;class_getMethodImplementation&lt;&#x2F;code&gt;和&lt;code&gt;class_getProperty&lt;&#x2F;code&gt;返回单个内容。&lt;&#x2F;p&gt;
&lt;p&gt;也有一些通用的自省方法，如&lt;code&gt;class_conformsToProtocol&lt;&#x2F;code&gt;, &lt;code&gt;class_respondsToSelector&lt;&#x2F;code&gt;, &lt;code&gt;class_getSuperclass&lt;&#x2F;code&gt;。最后，你可以使用&lt;code&gt;class_createInstance&lt;&#x2F;code&gt;来创建一个 object。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ivar&quot;&gt;ivar&lt;&#x2F;h4&gt;
&lt;p&gt;这些方法能让你得到名字，内存地址和 Objective-C type encoding。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;method&quot;&gt;method&lt;&#x2F;h4&gt;
&lt;p&gt;这些方法主要用来自省，比如&lt;code&gt;method_getName&lt;&#x2F;code&gt;, &lt;code&gt;method_getImplementation&lt;&#x2F;code&gt;, &lt;code&gt;method_getReturnType&lt;&#x2F;code&gt;等等。也有一些修改的方法，包括&lt;code&gt;method_setImplementation&lt;&#x2F;code&gt;和&lt;code&gt;method_exchangeImplementations&lt;&#x2F;code&gt;，这些我们后面会讲到。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;objc&quot;&gt;objc&lt;&#x2F;h4&gt;
&lt;p&gt;一旦拿到了 object，你就可以对它做一些自省和修改。你可以 get&#x2F;set ivar, 使用&lt;code&gt;object_copy&lt;&#x2F;code&gt;和&lt;code&gt;object_dispose&lt;&#x2F;code&gt;来 copy 和 free object 的内存。最 NB 的不仅是拿到一个 class，而是可以使用&lt;code&gt;object_setClass&lt;&#x2F;code&gt;来改变一个 object 的 class。待会就能看到使用场景。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;property&quot;&gt;property&lt;&#x2F;h4&gt;
&lt;p&gt;属性保存了很大一部分信息。除了拿到名字，你还可以使用&lt;code&gt;property_getAttributes&lt;&#x2F;code&gt;来发现 property 的更多信息，如返回值、是否为 atomic、getter&#x2F;setter 名字、是否为 dynamic、背后使用的 ivar 名字、是否为弱引用。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;protocol&quot;&gt;protocol&lt;&#x2F;h4&gt;
&lt;p&gt;Protocols 有点像 classes，但是精简版的，运行时的方法是一样的。你可以获取 method, property, protocol 列表, 检查是否实现了其他的 protocol。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sel&quot;&gt;sel&lt;&#x2F;h4&gt;
&lt;p&gt;最后我们有一些方法可以处理 selectors，比如获取名字，注册一个 selector 等等。&lt;&#x2F;p&gt;
&lt;p&gt;现在我们对 Objective-C 的运行时有了大概的了解，来看看它们能做哪些有趣的事情。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;classes-and-selectors-from-strings&quot;&gt;Classes And Selectors From Strings&lt;&#x2F;h2&gt;
&lt;p&gt;比较基础的一个动态特性是通过 String 来生成 Classes 和 Selectors。Cocoa 提供了&lt;code&gt;NSClassFromString&lt;&#x2F;code&gt;和&lt;code&gt;NSSelectorFromString&lt;&#x2F;code&gt;方法，使用起来很简单：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;Class&lt;&#x2F;span&gt;&lt;span&gt; stringclass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;NSClassFromString&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;NSString&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;于是我们就得到了一个 string class。接下来：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;myString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[stringclass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;stringWithString:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;Hello World&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为什么要这么做呢？直接使用 Class 不是更方便？通常情况下是，但有些场景下这个方法会很有用。首先，可以得知是否存在某个 class，&lt;code&gt;NSClassFromString&lt;&#x2F;code&gt; 会返回 nil，如果运行时不存在该 class 的话。比如可以检查&lt;code&gt;NSClassFromString(@&amp;quot;NSRegularExpression&amp;quot;)&lt;&#x2F;code&gt;是否为 nil 来判断是否为 iOS4.0+。&lt;&#x2F;p&gt;
&lt;p&gt;另一个使用场景是根据不同的输入返回不同的 class 或 method。比如你在解析一些数据，每个数据项都有要解析的字符串以及自身的类型（String，Number，Array）。你可以在一个方法里搞定这些，也可以使用多个方法。其中一个方法是获取 type，然后使用 if 来调用匹配的方法。另一种是根据 type 来生成一个 selector，然后调用之。以下是两种实现方式：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)parseObject&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;)object {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;data in object) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;([[data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;] isEqualToString&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;String&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]) {
&lt;&#x2F;span&gt;&lt;span&gt;            [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;parseString:[data value]&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;([[data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;] isEqualToString&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;Number&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]) {
&lt;&#x2F;span&gt;&lt;span&gt;            [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;parseNumber:[data value]&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;([[data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;] isEqualToString&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;Array&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]) {
&lt;&#x2F;span&gt;&lt;span&gt;            [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;parseArray:[data value]&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)parseObjectDynamic&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;)object {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;data in object) {
&lt;&#x2F;span&gt;&lt;span&gt;    	[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;performSelector:NSSelectorFromString([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;stringWithFormat:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;parse&lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, [data type]]) withObject:[data value]&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)parseString&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)aString {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)parseNumber&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)aNumber {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)parseArray&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)aArray {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可一看到，你可以把 7 行带 if 的代码变成 1 行。将来如果有新的类型，只需增加实现方法即可，而不用再去添加新的 else if。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;method-swizzling&quot;&gt;Method Swizzling&lt;&#x2F;h2&gt;
&lt;p&gt;之前我们讲过，方法由两个部分组成。Selector 相当于一个方法的 id；IMP 是方法的实现。这样分开的一个便利之处是 selector 和 IMP 之间的对应关系可以被改变。比如一个 IMP 可以有多个 selectors 指向它。&lt;&#x2F;p&gt;
&lt;p&gt;而 Method Swizzling 可以交换两个方法的实现。或许你会问“什么情况下会需要这个呢？”。我们先来看下 Objective-C 中，两种扩展 class 的途径。首先是 subclassing。你可以重写某个方法，调用父类的实现，这也意味着你必须使用这个 subclass 的实例，但如果继承了某个 Cocoa class，而 Cocoa 又返回了原先的 class(比如 NSArray)。这种情况下，你会想添加一个方法到 NSArray，也就是使用 Category。99%的情况下这是 OK 的，但如果你重写了某个方法，就没有机会再调用原先的实现了。&lt;&#x2F;p&gt;
&lt;p&gt;Method Swizzling 可以搞定这个问题。你可以重写某个方法而不用继承，同时还可以调用原先的实现。通常的做法是在 category 中添加一个方法(当然也可以是一个全新的 class)。可以通过&lt;code&gt;method_exchangeImplementations&lt;&#x2F;code&gt;这个运行时方法来交换实现。来看一个 demo，这个 demo 演示了如何重写&lt;code&gt;addObject:&lt;&#x2F;code&gt;方法来纪录每一个新添加的对象。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#import  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;lt;objc&#x2F;runtime.h&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@interface &lt;&#x2F;span&gt;&lt;span&gt;NSMutableArray (LoggingAddObject)
&lt;&#x2F;span&gt;&lt;span&gt;- (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;logAddObject:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;aObject&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@implementation &lt;&#x2F;span&gt;&lt;span&gt;NSMutableArray (LoggingAddObject)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;+ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;load &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Method addobject &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_getInstanceMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(addObject:))&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    Method logAddobject &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_getInstanceMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(logAddObject:))&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;method_exchangeImplementations&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(addObject, logAddObject)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;- (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;logAddObject:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;aobject &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;logAddObject:aObject&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;NSLog&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;Added object &lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt; to array &lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, aObject, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们把方法交换放到了&lt;code&gt;load&lt;&#x2F;code&gt;中，这个方法只会被调用一次，而且是运行时载入。如果指向临时用一下，可以放到别的地方。注意到一个很明显的递归调用&lt;code&gt;logAddObject:&lt;&#x2F;code&gt;。这也是 Method Swizzling 容易把我们搞混的地方，因为我们已经交换了方法的实现，所以其实调用的是&lt;code&gt;addObject:&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;pilky.me&#x2F;static&#x2F;blogmedia&#x2F;objcdynamictips_methodswizzling.png&quot; alt=&quot;Method Swizzling&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dong-tai-ji-cheng-jiao-huan&quot;&gt;动态继承、交换&lt;&#x2F;h2&gt;
&lt;p&gt;我们可以在运行时创建新的 class，这个特性用得不多，但其实它还是很强大的。你能通过它创建新的子类，并添加新的方法。&lt;&#x2F;p&gt;
&lt;p&gt;但这样的一个子类有什么用呢？别忘了 Objective-C 的一个关键点：object 内部有一个叫做&lt;code&gt;isa&lt;&#x2F;code&gt;的变量指向它的 class。这个变量可以被改变，而不需要重新创建。然后就可以添加新的 ivar 和方法了。可以通过以下命令来修改一个 object 的 class&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;object_setClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(myObject, [MySubclass class])&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这可以用在 Key Value Observing。当你开始 observing an object 时，Cocoa 会创建这个 object 的 class 的 subclass，然后将这个 object 的 isa 指向新创建的 subclass。点击&lt;a href=&quot;http:&#x2F;&#x2F;www.mikeash.com&#x2F;pyblog&#x2F;friday-qa-2009-01-23.html&quot;&gt;这里&lt;&#x2F;a&gt;查看更详细的解释。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dong-tai-fang-fa-chu-li&quot;&gt;动态方法处理&lt;&#x2F;h2&gt;
&lt;p&gt;目前为止，我们讨论了方法交换，以及已有方法的处理。那么当你发送了一个 object 无法处理的消息时会发生什么呢？很明显，&amp;quot;it breaks&amp;quot;。大多数情况下确实如此，但 Cocoa 和 runtime 也提供了一些应对方法。&lt;&#x2F;p&gt;
&lt;p&gt;首先是&lt;strong&gt;动态方法处理&lt;&#x2F;strong&gt;。通常来说，处理一个方法，运行时寻找匹配的 selector 然后执行之。有时，你只想在运行时才创建某个方法，比如有些信息只有在运行时才能得到。要实现这个效果，你需要重写&lt;code&gt;+resolveInstanceMethod:&lt;&#x2F;code&gt; 和&#x2F;或 &lt;code&gt;+resolveClassMethod:&lt;&#x2F;code&gt;。如果确实增加了一个方法，记得返回 YES。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;BOOL&lt;&#x2F;span&gt;&lt;span&gt;)resolveInstanceMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;SEL&lt;&#x2F;span&gt;&lt;span&gt;)aSelector {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(aSelector &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;myDynamicMethod&lt;&#x2F;span&gt;&lt;span&gt;)) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_addMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, aSelector, (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;IMP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)myDynamicIMP, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;v@:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;YES&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;super &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;resolveInstanceMethod:aSelector&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那 Cocoa 在什么场景下会使用这些方法呢？Core Data 用得很多。NSManagedObjects 有许多在运行时添加的属性用来处理 get&#x2F;set 属性和关系。那如果 Model 在运行时被改变了呢？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xiao-xi-zhuan-fa&quot;&gt;消息转发&lt;&#x2F;h2&gt;
&lt;p&gt;如果 resolve method 返回 NO，运行时就进入下一步骤：消息转发。有两种常见用例。1) 将消息转发到另一个可以处理该消息的 object。2) 将多个消息转发到同一个方法。&lt;&#x2F;p&gt;
&lt;p&gt;消息转发分两步。首先，运行时调用&lt;code&gt;-forwardingTargetForSelector:&lt;&#x2F;code&gt;，如果只是想把消息发送到另一个 object，那么就使用这个方法，因为更高效。如果想要修改消息，那么就要使用&lt;code&gt;-forwardInvocation:&lt;&#x2F;code&gt;，运行时将消息打包成 NSInvocation，然后返回给你处理。处理完之后，调用&lt;code&gt;invokeWithTarget:&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Cocoa 有几处地方用到了消息转发，主要的两个地方是代理(Proxies)和响应链(Responder Chain)。NSProxy 是一个轻量级的 class，它的作用就是转发消息到另一个 object。如果想要惰性加载 object 的某个属性会很有用。NSUndoManager 也有用到，不过是截取消息，之后再执行，而不是转发到其他的地方。&lt;&#x2F;p&gt;
&lt;p&gt;响应链是关于 Cocoa 如何处理与发送事件与行为到对应的对象。比如说，使用 Cmd+C 执行了 copy 命令，会发送&lt;code&gt;-copy:&lt;&#x2F;code&gt;到响应链。首先是 First Responder，通常是当前的 UI。如果没有处理该消息，则转发到下一个&lt;code&gt;-nextResponder&lt;&#x2F;code&gt;。这么一直下去直到找到能够处理该消息的 object，或者没有找到，报错。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yong-block-zuo-wei-method-imp&quot;&gt;使用 Block 作为 Method IMP&lt;&#x2F;h2&gt;
&lt;p&gt;iOS 4.3 带来了很多新的 runtime 方法。除了对 properties 和 protocols 的加强，还带来一组新的以 imp 开头的方法。通常一个 IMP 是一个指向方法实现的指针，头两个参数为 object(self)和 selector(_cmd)。iOS 4.0 和 Mac OS X 10.6 带来了 block，&lt;code&gt;imp_implementationWithBlock()&lt;&#x2F;code&gt; 能让我们使用 block 作为 IMP，下面这个代码片段展示了如何使用 block 来添加新的方法。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;m&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-m &quot;&gt;&lt;code class=&quot;language-m&quot; data-lang=&quot;m&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;IMP&lt;&#x2F;span&gt;&lt;span&gt; myIMP &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;imp_implementationWithBlock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;^&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;_self, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c99e00;&quot;&gt;NSString &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;string) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;	NSLog(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;@&amp;quot;Hello &lt;&#x2F;span&gt;&lt;span&gt;%@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, string);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;})&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;class_addMethod&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;([MYclass class], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;@selector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(sayHello:), myIMP, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;v@:@&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果想知道这是如何实现的，可以查看&lt;a href=&quot;http:&#x2F;&#x2F;www.friday.com&#x2F;bbum&#x2F;2011&#x2F;03&#x2F;17&#x2F;ios-4-3-imp_implementationwithblock&#x2F;&quot;&gt;这篇文章&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以看到，Objective-C 表面看起来挺简单，但还是很灵活的，可以带来很多可能性。动态语言的优势在于在不扩展语言本身的情况下做很多很灵巧的事情。比如 Key Value Observing，提供了优雅的 API 可以与已有的代码无缝结合，而不需要新增语言级别的特性。&lt;&#x2F;p&gt;
&lt;p&gt;希望这篇文章能让你更深入地了解 Objective-C，在开发 app 时也能开阔思路，考虑更多的可能性。&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)How To Find What You Love To Do</title>
            <pubDate>Sun, 04 Sep 2011 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/how-to-find-what-you-love-to-do/</link>
            <guid>https://limboy.me/posts/how-to-find-what-you-love-to-do/</guid>
            <description>&lt;p&gt;我们都知道要做自己喜欢的，但自己真正喜欢什么，却未必清楚。也很少有时间问问自己：这辈子究竟要做些什么？怎么做才无愧此生？生活就像一个没有设置 break 的 while True 循环，一旦开始就停不下来了。上班要忙上班的事，周末要聚会，看电影，玩游戏，逛街，把上班时的痛苦补回来，然后在不情愿中迎接下一个周一。这是自己想要的生活吗？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;briankim.net&#x2F;blog&#x2F;2006&#x2F;07&#x2F;how-to-find-what-you-love-to-do&#x2F;&quot;&gt;原文链接&lt;&#x2F;a&gt;(gfwed)&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;这篇文章是受乔布斯在斯坦福大学的演讲的启发，在那次演讲中，他说了我们听了不下千次的建议：&lt;&#x2F;p&gt;
&lt;p&gt;bq. 你必须找到你所爱的。无论是工作还是爱人。工作将占据你生命中大部分时间，你只有相信自己所做的是伟大的工作, 才能怡然自得。而有伟大成就的唯一途径就是爱你所做的。-- Steve Jobs&lt;&#x2F;p&gt;
&lt;p&gt;这也自然而然地牵扯出另一个问题：&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-zhao-dao-zi-ji-suo-ai-de&quot;&gt;如何找到自己所爱的？&lt;&#x2F;h3&gt;
&lt;p&gt;这是一个大问题。&lt;&#x2F;p&gt;
&lt;p&gt;真正让自己热血沸腾的是我们可以一直做自己最爱的事，但却没有循序渐进的教程可以帮助我们找到自己所爱的。以往的经验能起一点作用，但无法形成一套体系。&lt;&#x2F;p&gt;
&lt;p&gt;为了找到自己的热情，可以问自己：如果有一百万美元，你想做什么？&lt;&#x2F;p&gt;
&lt;p&gt;典型的回答是：会把这些钱存入银行，然后每年光利息就可以生活了。然后会搬到夏威夷，买一个别墅，品尝所有的美味，看看书，搞点体育运动，等等。&lt;&#x2F;p&gt;
&lt;p&gt;这样的回答有帮助吗？可能吧。比如，你知道了自己原来是个大懒鬼，但这并没有回答背后的问题：如何能做自己喜欢的事，还能挣到钱？&lt;&#x2F;p&gt;
&lt;p&gt;人们从事着自己讨厌的工作，感觉像掉入了陷阱，因为他们无法离开，他们靠着这唯一的收入来维持目前的生活状态，以此来逃避现实，漂流在严酷、漫无目的的生活中，简而言之：活在平静的绝望中。&lt;&#x2F;p&gt;
&lt;p&gt;你或许会问：他们为什么不辞职，追求自己喜欢的呢？&lt;&#x2F;p&gt;
&lt;p&gt;两个原因：&lt;&#x2F;p&gt;
&lt;p&gt;原因 1：他们不知道自己最喜欢的事
原因 2：恐惧。他们要维持目前的生活，有账单要付，家人要照顾，怕没有稳定的收入来源，怕别人异样的目光或说三道四，等等。搞定原因 1，接下来的就会迎刃而解。&lt;&#x2F;p&gt;
&lt;p&gt;无论你信不信，想要找到自己的激情所在已经是一个很大的进步了。很多人，他们一生都在回避或者根本没想过这个问题。当他们听到这个问题时，会很熟练地忽视之。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ru-he-zhao-dao-zi-ji-suo-ai-de-zhe-shi-yi-ge-hen-zhong-yao-de-wen-ti-er-ni-bi-xu-zhao-dao-da-an&quot;&gt;如何找到自己所爱的？这是一个很重要的问题，而你必须找到答案&lt;&#x2F;h4&gt;
&lt;p&gt;你必须自己决定目的地，不然生活就会替你做决定。如果知道了目的地，剩下的就很简单了。&lt;&#x2F;p&gt;
&lt;p&gt;你会发现，一旦你找到了自己所爱的，所有的不确定、负担都会从你的肩上滑落，你会很清楚地看到自己的旅程，一趟充满欢喜的旅程。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;在你看完这篇文章时，我真心地希望你能够实践之。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wei-shi-yao-zhao-dao-zi-ji-suo-ai-de-na-yao-nan&quot;&gt;为什么找到自己所爱的那么难？&lt;&#x2F;h3&gt;
&lt;p&gt;答案是：&lt;&#x2F;p&gt;
&lt;p&gt;这一点都不难。是的，你没看错，一点都不难&lt;&#x2F;p&gt;
&lt;p&gt;那为什么这么多人都被这个问题所困扰呢？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;因为他们从未真正地问过自己&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我觉得很有意思的一件事是，人们好像总是要让自己做点什么，停不下来。比如：出去玩、聚会、逛街等等。不要误解，做这些事没有任何问题。但我怀疑大部分人都有这样的心态：我必须每时每分都做点什么，因为我做不了自己。只是想让自己在别人面前看起来风光一点。但事实上，要让自己充实起来，应该多花一点时间在自己身上。&lt;&#x2F;p&gt;
&lt;p&gt;人们以为必须环游世界，尝试新事物等等才能找到自己的所爱。不，你只要坐下来，然后决定。答案已经在你心里。你只要把它挖出来，别耽搁。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Just let it out.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;说实话，你有没有曾经独自一人坐下来，抛开手机，离开电脑，关上电视、聊天工具，关上自己最爱听的歌，关闭游戏，停止检查邮件、回复电话、浏览杂志等等其他一切分心的事，扪心自问：自己到底喜欢什么？&lt;&#x2F;p&gt;
&lt;p&gt;你害怕问题的答案，因为答案是：我不知道。&lt;&#x2F;p&gt;
&lt;p&gt;这也是为什么你必须找到答案的原因。承认自己不知道，这是 ok 的，比那些自动跳过的好多了。&lt;&#x2F;p&gt;
&lt;p&gt;下面让我们一步一步地来找到答案。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;step-1-hao-wu-yi-wen-ni-yi-ding-hui-zhao-dao-da-an&quot;&gt;Step 1: 毫无疑问，你一定会找到答案&lt;&#x2F;h4&gt;
&lt;p&gt;你一定会找到，无庸置疑。&lt;&#x2F;p&gt;
&lt;p&gt;带着这样的心态，你就一定会找到。会花多长时间？不重要。你终将会找到。&lt;&#x2F;p&gt;
&lt;p&gt;这样做，你会自动开启反放弃机制，因为你知道你一定会找到答案。&lt;&#x2F;p&gt;
&lt;p&gt;比如，如果你知道你要去纽约，你就会找到去那里的方法，你会搭车、火车或飞机，然后到达。&lt;&#x2F;p&gt;
&lt;p&gt;如果没有钱，你可以借，或者找份工作省钱，或者找一份空姐&#x2F;空哥的工作，这样就可以免费去那。花多长时间不重要，要做些什么也不重要，因为你知道你要去纽约。&lt;&#x2F;p&gt;
&lt;p&gt;你这个决定之后所有的行动都会围绕着『去纽约』而展开。&lt;&#x2F;p&gt;
&lt;p&gt;再读一遍最后这句&lt;&#x2F;p&gt;
&lt;p&gt;你这个决定之后所有的行动都会围绕着『去纽约』而展开。&lt;&#x2F;p&gt;
&lt;p&gt;找到你所爱的 ＝ 决定去纽约&lt;&#x2F;p&gt;
&lt;h4 id=&quot;step-2-fen-liang-lie-lie-yi-ge-ji-neng-qing-dan-he-xing-qu-lie-biao-bing-qie-xie-xia-lai&quot;&gt;Step 2: 分两列，列一个技能清单和兴趣列表，并且写下来&lt;&#x2F;h4&gt;
&lt;p&gt;再强调一遍：写下来。不要以为你可以在头脑中完成。&lt;&#x2F;p&gt;
&lt;p&gt;我这说的技能是任何技能。可以是无形的。比如编程，网页制作，聊天，倾听，说服别人，打字，调情，分析，演讲，让事情易于理解，吹口哨等等。不要害羞，列出所有自己的技能。&lt;&#x2F;p&gt;
&lt;p&gt;在另一列，列出自己的兴趣，同样，也不要害羞。列出所有你能想到的兴趣。蜘蛛、鞋子、头发、化妆品、篮球、网球、幻想、保姆、散步、ps、fireworks、帮助别人、搞笑、钓鱼、空手道、瓶起子等等，什么都行。是的，我提到了瓶起子。你的兴趣也可以包含自己擅长的方面。计算机、经济学、生物学、篮球、足球、魔术等等。&lt;&#x2F;p&gt;
&lt;p&gt;为了帮助你写下更多的兴趣爱好，想想之前的那份工作你最感兴趣的是什么，不感兴趣的又是什么。&lt;&#x2F;p&gt;
&lt;p&gt;问自己以下这些问题有助于发现自己追求的技能和兴趣&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你去一个书店，那个书架上的书对你的引力最大？问问朋友他们眼中你的技能和兴趣。你会惊叹于他们的洞察力。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;你把大多数的时间都花在了哪些事上？做这些事你期望得到怎样的结果？像小孩子一样想像自己的成就。都有哪些技能和兴趣对你的成就有帮助？&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;你做了什么别人会感谢你？&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;你的老师或家人有没有说过你有什么诀窍？&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;为什么我一再强调技能和兴趣？&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;技能：你必须依赖你的强项。不要告诉我你什么也没有。每个人都有技能。你只是没有坐下来细想，并且写下来。&lt;&#x2F;p&gt;
&lt;p&gt;兴趣：很简单，你必须爱你所做的。&lt;&#x2F;p&gt;
&lt;p&gt;专注于你能想到的兴趣和技能，并且写下来&lt;&#x2F;p&gt;
&lt;p&gt;你会发现你的技能好像受了引力作用一样偏向一种或两种技能，兴趣也一样。好，下面让我们进入步骤 3&lt;&#x2F;p&gt;
&lt;h4 id=&quot;step-3-wen-zheng-que-de-wen-ti-lai-zhao-dao-zi-ji-de-zui-ai&quot;&gt;Step 3：问正确的问题来找到自己的最爱&lt;&#x2F;h4&gt;
&lt;p&gt;找一个真正属于自己的时间和空间，没有任何分心的东西，通过问正确的问题来找到自己的最爱&lt;&#x2F;p&gt;
&lt;p&gt;我发现一个很有趣的现象，人们总是为税务、烹饪、电影、阅读留出时间，但是涉及到自己的将来时，却从来不会腾出时间。&lt;&#x2F;p&gt;
&lt;p&gt;现在，假如你已经安排了私人时间，没有杂事干扰，然后呢？&lt;&#x2F;p&gt;
&lt;p&gt;你必须问自己一个清晰的问题，清晰是关键，问题越清晰，回答越简单。&lt;&#x2F;p&gt;
&lt;p&gt;比如，我问，12x12 等于多少？答案很明了：144&lt;&#x2F;p&gt;
&lt;p&gt;如果我问两个偶数和另外两个偶数的乘积？这就很难回答了&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;清晰的问题引出清晰的答案&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;另外一个关键点是：写下来。我知道你听过一万次了，不过这是有原因的。把东西写下来有助于你在各项之间建立联系，这在脑海里是很难完成的。&lt;&#x2F;p&gt;
&lt;p&gt;如果你在之前的阶段没有写下技能和兴趣，那么停下，马上写下来。放在大脑里是不会有帮助的。&lt;&#x2F;p&gt;
&lt;p&gt;现在利用独处的时间问自己一个清晰的问题，这个问题会是：“我最喜欢做什么？”吗？&lt;&#x2F;p&gt;
&lt;p&gt;这个问题有点广泛了，再缩小一点，问自己：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;在每天的生活中，我最喜欢做什么，可以同时结合我的技能和兴趣，并给人们的生活带来重大价值？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;看到区别了吗？问题越具体，越清晰，回答起来就越方便。我为什么加了价值这一项，？因为这会帮助你找到挣钱的方法。&lt;&#x2F;p&gt;
&lt;p&gt;“通过技能和兴趣带来重大价值”，可以自动过滤那些普遍的答案，如：“看电视”，或“玩游戏”，这些答案往往会带来消极因素，因为看不到挣钱的方法。&lt;&#x2F;p&gt;
&lt;p&gt;顺带一句，很多人会误解这句话的核心，把重点放在了挣钱上。钱只是通过产品或服务为人们的生活带去方便的一个副产品&lt;&#x2F;p&gt;
&lt;p&gt;当你知道你可以为别人的生活带来方便时，你就会知道如何挣钱。&lt;&#x2F;p&gt;
&lt;p&gt;打开 Word 或纸张，在最前面写下这个问题。&lt;&#x2F;p&gt;
&lt;p&gt;在每天的生活中，我最喜欢做什么，可以同时结合我的技能和兴趣，并给人们的生活带来重大价值？&lt;&#x2F;p&gt;
&lt;p&gt;再强调一遍，重点是写下你自己的答案&lt;&#x2F;p&gt;
&lt;p&gt;看看之前列的两列清单，写下答案，有多少，写多少。不必完美，也不一定要有什么意义。因为迟早你会把这些关连起来。下面这个故事可以帮助阐述我的意思。&lt;&#x2F;p&gt;
&lt;p&gt;有一个小镇，以滑雪而出名，吸引了一大批游客前来，这对于促进经济有很大的作用。但是，下雪时，雪会沉积在电缆上，直到把电缆压跨，导致部分能源过载。慢慢的游客们都不来了，于是小镇举行了一个会议，讨论如何解决雪压跨电缆的问题。很久都没有好的解决方案。&lt;&#x2F;p&gt;
&lt;p&gt;突然有人在会议室的后面大声喊道“我们可以在电缆上放几盆蜂蜜，让熊爬上电缆，拿到蜂蜜，熊的这一系列动作会把电缆上的雪抖落”&lt;&#x2F;p&gt;
&lt;p&gt;在座的都笑了，有人接这个话茬“那我们怎么再在这些盆里放蜂蜜呢？”“可以用直升飞机”，另一个人说。&lt;&#x2F;p&gt;
&lt;p&gt;于是答案就出来了，让直升飞机在电缆上飞，通过螺旋桨的风力把雪吹落。&lt;&#x2F;p&gt;
&lt;p&gt;我想说的是，无论答案有多可笑，都不用害怕，因为它们常常能帮你找到最终的结果。这是过程的一部分。&lt;&#x2F;p&gt;
&lt;p&gt;所以无论多滑稽，写下来。写下所有的答案。直到你有了 20 个答案，然后回顾它们。你会发现，你写下的答案会帮助你找到新的答案。&lt;&#x2F;p&gt;
&lt;p&gt;你会惊叹写下的所有东西，以及各个富有创意的想法。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;现在又要集中注意力了&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;你肯定听过通过放大镜来聚焦阳光的事。但我还是想说，如果你打算一次处理多件事，那么哪件事都完不成。即使在最热的天，如果你不停移动放大镜，并不会聚焦多大的能量，什么也烧不着。只是无端地浪费自己的精力。&lt;&#x2F;p&gt;
&lt;p&gt;通过管理你的精力，时间，思考等等，在攻克一个目标时，你会惊叹目标完成的深度和效率。就像你在一个东西上放了一个放大镜，而你的欲望，精力，时间，思考，想像就是太阳光。&lt;&#x2F;p&gt;
&lt;p&gt;专注很重要，这里我想再举个例子。想像自己是一只猎豹，正在追逐两只羚羊。如果想同时追逐两个的话，那么什么也抓不到，只能饿死。先拿下一只，这可能需要时间去追击去撕咬，但当你真的吃掉了它，你又充满电了。你可以收集信息：羚羊都往哪个方向跑了，可能在哪块停留，等等。这有助于你今后捕获更多的羚羊，这就形成了良性循环。简而言之：专注于一个目标。&lt;&#x2F;p&gt;
&lt;p&gt;所以检查你刚刚的列表，选择一个最感兴趣的。你可能会发现，你可以把多个想法集中到一个。最好选择一个不仅能给自己带来极大的满足感，还能够帮助别人的想法。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ru-he-zhi-dao-zi-ji-yi-jing-zhao-dao-liao-zui-ai&quot;&gt;如何知道自己已经找到了最爱？&lt;&#x2F;h4&gt;
&lt;p&gt;做这件事让你觉得爽吗？如果发自肺腑地觉得很爽，那就对了。&lt;&#x2F;p&gt;
&lt;p&gt;如果你的朋友跟你谈论这个话题，你愿意跟他没完没了地谈论吗？&lt;&#x2F;p&gt;
&lt;p&gt;你必须毫无保留地喜欢这件事。如果你感到一丁点的怀疑，那这就不是你的激情所在。你必须急切地渴望克服任何困难来追逐你的激情。&lt;&#x2F;p&gt;
&lt;p&gt;一旦你找到了这件事，你的任务就完成了。&lt;&#x2F;p&gt;
&lt;p&gt;至于如何通过它来挣钱，在你写下答案时，可能已经找到方法了。如果想找到更多挣钱的方法，只需重复之前的步骤。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step 1: 毫无疑问，你一定会找到答案&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Step 2: 分两列，列一个技能清单和兴趣列表，并且写下来，你会发现其实有很多挣钱的方法&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;挣钱的方法只能靠你自己了，不过对你来说应该不难。&lt;&#x2F;p&gt;
&lt;p&gt;现在你知道了自己的最爱以及如何挣钱，该是行动的时候了。&lt;&#x2F;p&gt;
&lt;p&gt;很多人看到这里，没有任何行动，所以他们的生活也没有发生任何变化。&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)facebook是如何管理代码的</title>
            <pubDate>Tue, 18 Jan 2011 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/how-facebook-ships-code/</link>
            <guid>https://limboy.me/posts/how-facebook-ships-code/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;framethink.wordpress.com&#x2F;2011&#x2F;01&#x2F;17&#x2F;how-facebook-ships-code&#x2F;&quot;&gt;原文在此&lt;&#x2F;a&gt;，看完之后，终于明白为什么优秀的工程师都去了&#x2F;想去 facebook，因为那里是工程师们的天堂。&lt;&#x2F;p&gt;
&lt;p&gt;译文:&lt;&#x2F;p&gt;
&lt;p&gt;我对 facebook 的运转着迷。这是一个很独特的环境，不容易被复制（他们的体系并不适合所有的公司，即使他们努力尝试过）。下面是我和 facebook 的朋友们关于他们如何开发和管理项目的记录。&lt;&#x2F;p&gt;
&lt;p&gt;现在距离我收集的这些信息又过去 6 个月了，我相信 facebook 肯定又对他们的项目开发实践进行了改进。所以这些记录可能会有点过时。同时 facebook 的工程师驱动文化也越来越为大众所知。非常感谢那些帮助我整理这篇文章的 facebook 的朋友们。&lt;&#x2F;p&gt;
&lt;p&gt;记录：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;截止到 2010 年 6 月，facebook 有将近 2000 名员工，10 个月前只有 1100 名，一年之间差不多翻了一番。&lt;&#x2F;li&gt;
&lt;li&gt;两个最大的部门是工程师和运维，每个部门大概都是 400-500 人。这两个部门人数大约占了公司的一半。&lt;&#x2F;li&gt;
&lt;li&gt;产品经理与工程师的比例大约为 1-7 到 1-10。&lt;&#x2F;li&gt;
&lt;li&gt;每个工程师入职时，都要接收 4-6 周的培训，通过修补 bugs 和听高级开发工程师的课程来熟悉 facebook。&lt;&#x2F;li&gt;
&lt;li&gt;培训结束后，每个工程师都可以接触线上的数据库(更大的权力意味着更大的责任，也有一份&amp;quot;勿做清单&amp;quot;，不然可能会被开，比如共享用户的隐私数据)。&lt;&#x2F;li&gt;
&lt;li&gt;有非常牢靠的安全体系，以免有人不小心&#x2F;故意做了些不好的事。&lt;&#x2F;li&gt;
&lt;li&gt;每个工程师可以修改 facebook 的任何代码，随时可以迁入。&lt;&#x2F;li&gt;
&lt;li&gt;浓厚的工程师驱动文化。&amp;quot;产品经理基本可以被忽略&amp;quot;，这是 facebook 一名员工的话。工程师可以修改流程的细节，重新安排工作任务，随时植入自己的想法。&lt;&#x2F;li&gt;
&lt;li&gt;在每月的跨部门会议上，由工程师来汇报工作进度，市场部和产品经理会出席会议，也可以做些简短的发言，但如果说得太多，很可能就会被打小报告。他们确实想让工程师来主导产品的开发，对自己的产品负责。&lt;&#x2F;li&gt;
&lt;li&gt;项目需要的资源都是自愿的
** 一个产品经理把工程师们召集到一起，让他们对他的想法产生兴趣。
** 工程师们决定开发那些让他们感兴趣的特性。
** 工程师跟他们的经理说：&amp;quot;我下周想开发这 5 个新特性&amp;quot;。
** 经理会让工程师独立开发，可能有时会让他优先完成一些特性。
** 工程师独立完成所有的特性——前端&#x2F;后端&#x2F;数据库，等等所有相关的部分。如果需要得到设计人员的帮助，需要先让设计人员对你的想法产生兴趣。其他如架构之类的也一样。但总体来说，工程师要独立完成所有的任务。&lt;&#x2F;li&gt;
&lt;li&gt;对于某个特性是否值得开发的争论，通常是这么解决的：花一个星期的时间完成他，并在小部分人群中(如 1%)进行测试。&lt;&#x2F;li&gt;
&lt;li&gt;工程师常常希望解决难题，这能获得声望和尊敬。他们很难对前端项目或 UI 设计产生太大的兴趣。这跟其他公司可能正好相反。在 facebook，后端任务，比如新的 feed 算法，广告投放算法，memcache 优化等等，是工程师真正感兴趣的。&lt;&#x2F;li&gt;
&lt;li&gt;所有的代码修改都要进行审核(通过一个或多个工程师)，但 News Feed 是个例外，因为太重要了，Zuckerberg 会亲自 review。&lt;&#x2F;li&gt;
&lt;li&gt;所有的修改至少要被一个人审核，而且这个系统可以让任何人很方便地审核其他人的代码，即使你没有邀请他&lt;&#x2F;li&gt;
&lt;li&gt;工程师负责测试，代码修复，和维护自己的项目。&lt;&#x2F;li&gt;
&lt;li&gt;每个办公室或通过 VPN 连接的员工会使用下一版的 facebook，这个版本的 facebook 会经常更新，通常比公开的早 1-12 小时。所有的员工被强烈建议提交 bugs，而且通常会很快被修复。&lt;&#x2F;li&gt;
&lt;li&gt;很奇怪只有很少的 QA 或自动测试——&amp;quot;大部分工程师都能写出基本没有 bug 的代码，只是在其他公司他们不需要这么做。如果有 QA 部门，他们只要把代码写完，扔给他们就行了&amp;quot;&lt;&#x2F;li&gt;
&lt;li&gt;[针对上一条]我们有自动测试，代码发布前必须要通过测试。我们不相信&amp;quot;所有的工程师都能写出没有 bug 的代码&amp;quot;，毕竟这是一个商业公司。&lt;&#x2F;li&gt;
&lt;li&gt;很奇怪，缺少产品经理的影响和控制——产品经理是很独立的和自由的。产生影响力的关键是与工程师和工程师的领导们们搞好关系。需要大致了解技术，不要提一些愚蠢的想法。&lt;&#x2F;li&gt;
&lt;li&gt;所有提交的代码每周二打包一次。&lt;&#x2F;li&gt;
&lt;li&gt;只要多一分努力，终于一天会发生改变。&lt;&#x2F;li&gt;
&lt;li&gt;星期二的代码发布，需要所有的提交过代码的工程师在场。&lt;&#x2F;li&gt;
&lt;li&gt;代码打包前，工程师必须在一个特殊的 IRC channel 上。&lt;&#x2F;li&gt;
&lt;li&gt;运维执行打包过程
** facebook 有大约 60000 台服务器
** 有 9 个代码发布级别
** 最小的级别只有 6 台服务器
** 星期二的代码发布会先发布到 6 台服务器上，运维组会检测这 6 台服务器的反应，保证代码正常工作，然后再提交到下一级
** 如果发布出现了一些问题（如报错等等），那么就停止下一级的部署，提交出错代码的工程师负责修复问题，然后从头继续发布。
** 所以一次发布可能会经历几次重复：1-2-3-fix. 回到 1. 1-2-3-4-5-fix. 回到 1. 1-2-3-4-5-6-7-8-9&lt;&#x2F;li&gt;
&lt;li&gt;运维组是受过严格训练，倍受尊敬，而且有商业意识的。他们的工作包括分析错误日志，负载和内存状态等等。还包括用户行为。&lt;&#x2F;li&gt;
&lt;li&gt;代码发布期间，运维组使用 IRC-based 页面系统，可以通过 facebook&#x2F;email&#x2F;irc&#x2F;im&#x2F;sms ping 每一个工程师，如果需要他们注意的话。对运维组不做回应是一件很羞愧的事。&lt;&#x2F;li&gt;
&lt;li&gt;代码一旦发布到第 9 级，并且稳定运行，就算发布成功了。&lt;&#x2F;li&gt;
&lt;li&gt;如果一个特性没有按时完成，也没什么大不了的，下次完成时一并发布即可。&lt;&#x2F;li&gt;
&lt;li&gt;如果被 svn-blamed,public shamed 或工作经常疏忽就很可能被开除。&amp;quot;这是一个高效的文化&amp;quot;。不够高效或者不够聪明的员工会被剔除。管理层会在 6 个月的时间里观察你表现，如果不合格，只能说再见。每一级都是这个待遇，即使是 C 级别和 VP 级别，如果不够高效，也会被开除。&lt;&#x2F;li&gt;
&lt;li&gt;被责骂不会导致解雇。我们特别尊重别人，原谅别人。大部分高级工程师都或多或少犯过一些严重的错误，包括我。但没有人因此被解雇。&lt;&#x2F;li&gt;
&lt;li&gt;我也没有遇到过因为上面提到过的犯错误而被解雇。有些人犯了错，他们会非常努力地去修复，也让其他人得到了学习。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)Git开发管理之道</title>
            <pubDate>Sat, 30 Oct 2010 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/a-successful-git-branch/</link>
            <guid>https://limboy.me/posts/a-successful-git-branch/</guid>
            <description>&lt;p&gt;Git 的强大是众所周知的，本文要分享的是关于&amp;quot;使用 Git 的分支和合并功能来进行版本管理的开发模型&amp;quot;。以下是译文，&lt;a href=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;posts&#x2F;a-successful-git-branching-model&#x2F;&quot;&gt;原文地址&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这篇文章我想介绍一下一年前就提到过的我所有项目(工作&#x2F;私有)都在使用的开发模式，经过事实验证，确实非常可行。很早就想写了，一直没腾出时间。我不会涉及项目的细节，只是谈谈分支的使用策略和发布管理。&lt;&#x2F;p&gt;
&lt;img src=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;img&#x2F;git-model@2x.png&quot; &#x2F;&gt;
&lt;p&gt;上图是使用 Git 这个版本控制工具来管理所有源码的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wei-shi-yao-shi-yong-git&quot;&gt;为什么使用 Git&lt;&#x2F;h3&gt;
&lt;p&gt;如果要看详细的 Git 与集中式源码管理工具的优势与劣势，可以参见&lt;a href=&quot;http:&#x2F;&#x2F;git.or.cz&#x2F;gitwiki&#x2F;GitSvnComparsion&quot;&gt;这篇文章&lt;&#x2F;a&gt;，那里有很多口水仗。作为一个开发人员，所有的源码管理工具中，我最喜欢 Git。Git 从根本上改变了开发人员对分支和合并的使用，传统的 CVS&#x2F;SVN，分支和合并都是高级话题，而且使用起来稍显麻烦，隔一段时间才会用一次。但是有了 Git，这些操作就成了家常便饭。&lt;&#x2F;p&gt;
&lt;p&gt;由于使用简单，方便重复操作，分支和合并不再是让人望而生畏的操作，版本管理工具应该尽可能地对分支&#x2F;合并提供最好的支持。&lt;&#x2F;p&gt;
&lt;p&gt;工具谈得差不多了，回到开发上。我待会要讲到的模型其实是一些每个开发人员都应该遵守的步骤，如果想管理好软件的开发流程的话。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fen-bu-shi-dan-ji-zhong-hua&quot;&gt;分布式但集中化&lt;&#x2F;h3&gt;
&lt;p&gt;我们要使用的仓库是一个&amp;quot;中心库&amp;quot;，当然这个中心库只是被认为是这样(因为 Git 是分布式的，从技术层面上来说是没有中心库的)，我们将把这个仓库叫做&amp;quot;origin&amp;quot;，因为 Git 用户都熟悉这个名字。&lt;&#x2F;p&gt;
&lt;img src=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;img&#x2F;centr-decentr@2x.png&quot; &#x2F;&gt;
&lt;p&gt;每个开发者 pull 和 push 到 origin，但除了中心化的 push-pull 关系外，每个开发者还可以从其他开发者那 pull changes。比如说，对于一个比较大的新特性，在把代码提交到 origin 之前，很可能会安排 2 个或多个开发者。上图中有几个小团队：Alice 和 Bob，Alice 和 David，Clair 和 David。&lt;&#x2F;p&gt;
&lt;p&gt;从技术角度来说，其实就是 Alice 定义了一个叫 Bob 的 Git remote，指向到 Bob 的仓库。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;main-fen-zhi&quot;&gt;main 分支&lt;&#x2F;h3&gt;
&lt;p&gt;中心仓库有两个分支：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;master&lt;&#x2F;li&gt;
&lt;li&gt;develop&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;origin 上的 master 分支，Git 用户应该很熟悉，跟 master 并行的有一个 develop 分支&lt;&#x2F;p&gt;
&lt;img src=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;img&#x2F;main-branches@2x.png&quot; &#x2F;&gt;
&lt;p&gt;我们把 origin&#x2F;master 作为主要分支，源码的 HEAD 总是表示 production-ready(可随时部署)状态。而 origin&#x2F;develop 上的代码是为下一次的代码发布准备的。每日构建也是基于此分支。&lt;&#x2F;p&gt;
&lt;p&gt;当 develop 分支达到了一个稳定状态并准备发布时，所有的改变都要合并到 master 分支，并标上版本号。如何实现的下面细说。&lt;&#x2F;p&gt;
&lt;p&gt;这样每次与 master 合并都会有新的部署发布。这点可以自动化，如使用 Git hook 脚本来实现自动部署代码到线上。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhi-chi-supporting-fen-zhi&quot;&gt;支持(supporting)分支&lt;&#x2F;h3&gt;
&lt;p&gt;我们的开发模型使用了一些支持分支放在 master 和 develop 分支的旁边，方便开发小组之间的并行开发。不像 main 分支，这些分支是有时间限制的，因为他们最终都会被移除。&lt;&#x2F;p&gt;
&lt;p&gt;我们会使用到的不同的分支&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Feature branches&lt;&#x2F;li&gt;
&lt;li&gt;Release branches&lt;&#x2F;li&gt;
&lt;li&gt;Hotfix branches&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;每个分支都有各自的作用，并且有严格的规定，如：只能从哪个分支上去新开分支，只能合并到那个分支。这个待会细说。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;feature-branches&quot;&gt;Feature branches&lt;&#x2F;h3&gt;
&lt;img src=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;img&#x2F;fb@2x.png&quot; &#x2F;&gt;
&lt;p&gt;继承分支: develop
合并分支：develop
命名规范：除了 master,develop,release-&lt;em&gt;,hotfix-&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Feature branches 是用来开发新特性的(短期，远期都可以)。当开始开发新特性时，很可能不知道这个特性会出现在哪个目标版本。一旦开发完成就可以合并到 develop，当然如果开发失败，就可以抛弃。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuang-jian-yi-ge-feature-branch&quot;&gt;创建一个 Feature branch&lt;&#x2F;h3&gt;
&lt;p&gt;当要创建一个新特性时，从 develop 分支上再进行分支&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; myfeature develop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to a new branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;myfeature&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;新特性完成时，可以合并到 develop&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout develop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;#39;develop&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; --no-ff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; myfeature
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Updating&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; ea1b82a..05e9557
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Summary&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; of changes&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git branch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; myfeature
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Deleted&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; branch myfeature (was 05e9557&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git push origin develop
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;aside class=&quot;info&quot; &gt;
  --no-ff (译者注：no fast foward)标签，使得每一次的合并都创建一个新的 commit 记录。即使这个 commit 只是 fast-foward，这样可以避免丢失信息
&lt;&#x2F;aside&gt;&lt;img src=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;img&#x2F;merge-without-ff@2x.png&quot; &#x2F;&gt;
&lt;p&gt;不幸的是，我没有找到让--no-ff 成为 commit 默认参数的方法(译者注：修改.consolerc?)，但确实应该提供一个方法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;release-branch&quot;&gt;Release branch&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#f9f9f9;color:#111111;&quot;&gt;&lt;code&gt;&lt;span&gt;继承分支: develop
&lt;&#x2F;span&gt;&lt;span&gt;合并分支：develop 和 master
&lt;&#x2F;span&gt;&lt;span&gt;命名规范：release-\*
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Release branch 是为新的 production release 准备的(译者注：相当于 RC 版)，可以有一些小的 bug，并为发布准备一些元数据(版本号，构建日期等等)。把所有的这些工作都放到 Release branch，develop branch 就能更清晰地知道下一个版本要开发哪些特性。&lt;&#x2F;p&gt;
&lt;p&gt;从 develop 分支合并到 release 分支的关键因素是:develop 分支达到了 release 分支所要求的状态。至少所有针对该 release 的特性要被合并。至于那些将来会有的特性可以先放一放。然后就是为接下来即将要发布的版本分配一个版本号。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuang-jian-yi-ge-release-branch&quot;&gt;创建一个 Release branch&lt;&#x2F;h3&gt;
&lt;p&gt;Release branch 是通过 develop 分支而创建。举个例子，假如 1.1.5 是当前的 production release，然后会有一个比较大的版本发布。develop 的状态已经可以发布版本了，经过商榷后，决定发布为 1.2 版本(而不是 1.1.6 或 2.0)，所以我们创建一个 release 分支，并给这个分支一个新的版本号&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; release-1.2 develop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to a new branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;release-1.2&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; .&#x2F;bump-version.sh 1.2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Files&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; modified successfully, version bumped to 1.2.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -a -m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;Bumped version number to 1.2&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;[release-1.2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 74d9424] Bumped version number to 1.2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; files changed, 1 insertions(+&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 1 deletions(-&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个新分支可能会存在一定的时间，直到可以被合并到 production branch。这段时间内，bug 修补可以在这个分支上进行(而不是 develop 分支)。添加新特性(尤其比较大的)是不允许的。最后还是要被合并到 develop，然后继续在 develop 分支上开发，直到下一个版本。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wan-cheng-yi-ge-release-branch&quot;&gt;完成一个 release branch&lt;&#x2F;h3&gt;
&lt;p&gt;当 release branch 已经准备就绪，需要做几件事。首先，release 分支被合并到 master 分支上(每一个提交到 master 上的 commit 都是一个新版本，切记)。然后 master 上的 commit 都要添加 tag，方便将来查看和回滚。最后 release 上所做的修改必须合并到 develop 分支上，保证 bug 已被修补。&lt;&#x2F;p&gt;
&lt;p&gt;前两个步骤：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout master
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;#39;master&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; --no-ff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; release-1.2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; made by recursive.
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Summary&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; of changes&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git tag&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 1.2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为了把 release 上的改变保存到 develop，我们需要合并到 develop&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout develop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;#39;develop&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; --no-ff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; release-1.2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; made by recursive.
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Summary&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; of changes&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个步骤可能会导致冲突，如果这样的话，解决冲突，然后再提交。&lt;&#x2F;p&gt;
&lt;p&gt;现在一切都完成了，可以把 release branch 干掉了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git branch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; release-1.2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Deleted&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; branch release-1.2 (was ff452fe&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;hotfix-branch&quot;&gt;Hotfix branch&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#f9f9f9;color:#111111;&quot;&gt;&lt;code&gt;&lt;span&gt;继承分支: master
&lt;&#x2F;span&gt;&lt;span&gt;合并分支：develop 和 master
&lt;&#x2F;span&gt;&lt;span&gt;命名规范：hotfix-\*
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Hotfix branch 和 Release branch 有几分相似，都是为了新的 production release 而准备的。比如运行过程中发现了 bug，就必须快速解决，这时就可以创建一个 Hotfix branch，解决完后合并到 master 分支上。好处是开发人员可以继续工作，有专人来负责搞定这个 bug。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chuang-jian-hotfix-branch&quot;&gt;创建 Hotfix branch&lt;&#x2F;h3&gt;
&lt;img src=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;img&#x2F;hotfix-branches@2x.png&quot; &#x2F;&gt;
&lt;p&gt;Hotfix 是从 master 分支上创建的。假如当前运行版本是 1.2，然后发现有 bug，但是 develop 还在开发中，不太稳定，这时就可以新开一个 Hotfix branch，然后开始解决问题。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; hotfix-1.2.1 master
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to a new branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;hotfix-1.2.1&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; .&#x2F;bump-version.sh 1.2.1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Files&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; modified successfully, version bumped to 1.2.1.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -a -m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;Bumped version number to 1.2.1&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;[hotfix-1.2.1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 41e61bb] Bumped version number to 1.2.1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; files changed, 1 insertions(+&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 1 deletions(-&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;解决问题，一次或几次 commit&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -m &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;quot;Fixed severe production problem&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;[hotfix-1.2.1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; abbe5d6] Fixed severe production problem
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; files changed, 32 insertions(+&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 17 deletions(-&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;wan-cheng-hotfix-branch&quot;&gt;完成 Hotfix branch&lt;&#x2F;h3&gt;
&lt;p&gt;当结束时，bugfix 要被合并到 master，同时也要合并到 develop，保证下个版本发布时该 bug 已被修复。这跟 release branch 完成时一样。&lt;&#x2F;p&gt;
&lt;p&gt;首先更新 master 和 tag release&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout master
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;#39;master&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; --no-ff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; hotfix-1.2.1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; made by recursive.
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Summary&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; of changes&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git tag&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; 1.2.1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来与 develop 合并&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git checkout develop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Switched&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; to branch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#839c00;&quot;&gt;&amp;#39;develop&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; --no-ff&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; hotfix-1.2.1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Merge&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; made by recursive.
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Summary&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; of changes&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有一个例外，就是当一个 release branch 存在时，bugfix 要被合并到 release 而不是 develop，因为 release 最终会被合并到 develop。&lt;&#x2F;p&gt;
&lt;p&gt;最后移除 branch&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; git branch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt; -d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; hotfix-1.2.1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;Deleted&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; branch hotfix-1.2.1 (was abbe5d6&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h3&gt;
&lt;p&gt;这个开发模型其实没有什么新颖的，一开始提到的&amp;quot;大图&amp;quot;确实在我们的项目起到了非常大的作用。这是很优雅的一个模型，很容易实现，也容易在团队成员之间达成一致。&lt;&#x2F;p&gt;
&lt;p&gt;PS:需要这个模型大图的，可以去&lt;a href=&quot;http:&#x2F;&#x2F;nvie.com&#x2F;posts&#x2F;a-successful-git-branching-model&#x2F;&quot;&gt;原文地址&lt;&#x2F;a&gt;下载&lt;&#x2F;p&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)如何辨别优秀的程序员</title>
            <pubDate>Fri, 27 Aug 2010 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/how-to-recognize-good-programmers/</link>
            <guid>https://limboy.me/posts/how-to-recognize-good-programmers/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.inter-sections.net&#x2F;2007&#x2F;11&#x2F;13&#x2F;how-to-recognise-a-good-programmer&#x2F;&quot;&gt;原文&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这并不是想象的那么容易。工作经历并不能说明什么问题，因为优秀的程序员并非总是有“正式”的工作经验来说明他们有多优秀。事实上工作经历往往会误导。&lt;&#x2F;p&gt;
&lt;p&gt;我觉得自己是一个非常优秀的程序员。同时，我也花费了大量的时间在商业圈，找技术人员做项目，面试别人等等。正是如此，我觉得自己有足够的经验去识别一个优秀的程序员，我会在下文中分享，希望能够帮助那些 “商业人士”更好地找到人才。那些有可能成为优秀程序员但还没有摸到门道的，也可以阅读这篇文章，从而发现自己需要改进的地方。&lt;&#x2F;p&gt;
&lt;p&gt;在 Paul Graham 的这篇“18 个错误导致创业失败”文章里提到：&lt;&#x2F;p&gt;
&lt;p&gt;bq. 在 90 年代，导致绝大多数创业失败的是那些劣质的程序员，很多这样的公司是几个商人共同创立的，他们有聪明的想法，然后让程序员来实现这些想法。但事实上要困难地多——因为那些企业家他们无法分辨一个程序员是否优秀。他们甚至都没有机会见到那些顶极的程序员。&lt;&#x2F;p&gt;
&lt;p&gt;事实上，那些商人选择自己认为优秀的程序员(比如简历上提到自己曾是微软的工程师)，但事实上不是。然后会发现创业之路就像二次大战一样艰难。&lt;&#x2F;p&gt;
&lt;p&gt;如果你不是程序员，如何来挑选优秀的程序员呢？我觉得没有最佳答案。我想说你最好找一个优秀的程序员来帮你筛选。但你如何找到这个人？&lt;&#x2F;p&gt;
&lt;p&gt;这点上，我不太同意 Graham。我觉得优秀的程序员有很多特质。即使一个商人也能识别。我下面来一一列举。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-ji-qing&quot;&gt;#1 激情&lt;&#x2F;h3&gt;
&lt;p&gt;在我与别人合作的经历中，遇到过很多技术员：他们写程序，因为他们觉得这是份不错的工作。业余时间从来不会去编程。当他们知道我家里有一个局域网和 3 台电脑时，显得很震惊。他们只是在工作，不会主动学习新事物，除非工作中需要，或者为了找份工作。当一天的工作结束时就再也不想谈论它了。有些人觉得工作之余谈工作不适合社交。但如果你想结识一个优秀的程序员，体现出自己的激情是很重要的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-zi-xue&quot;&gt;#2 自学&lt;&#x2F;h3&gt;
&lt;p&gt;时过境迁，编程语言也在不断进步和完善，新的技术会出现，新的标准也会到来。当然不是说，所有优秀的程序员都对那些事物有浓厚的兴趣，但有很多程序员他们从来不会主动学习新事物，除非迫不得已，因为他们不喜欢学习新东西。这些人往往是在大学时学的计算机专业，然后渴望毕业后找到份好工作。&lt;&#x2F;p&gt;
&lt;p&gt;如果你打算雇佣某个程序员，只要提到“我能掌握那个，只要把我送到培训中心一个星期”。不要雇佣那样的人。优秀的程序员不需要培训中心。事实上，优秀的程序员会提到你从未听过的信技术，然后向你解释为什么必须用它，即使他都不知道如何使用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-cong-hui&quot;&gt;#3 聪慧&lt;&#x2F;h3&gt;
&lt;p&gt;有些商人觉得缺乏情商就是不够聪慧。事实上聪慧包括很多因素，情商只是其中之一。优秀的程序员不是不会说话，事实上，优秀的程序员通常是你认识的人中最聪明的。他们中的很多人有很好的社交能力。我参加过几次 London Ruby User 聚会，除了少数几个特例，大多数人都很聪明，善谈，兴趣广泛等等。但你不会在公众场合看到他们谈论，然后会想“这是怎样的一帮 geek 啊”。&lt;&#x2F;p&gt;
&lt;p&gt;不要认为那些话不多的人就是好的程序员。他们不是，如果在完全放松的环境下都不能很好地交流，他们不是优秀程序员的概率会很大。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-yin-cang-ji-neng&quot;&gt;#4 隐藏技能&lt;&#x2F;h3&gt;
&lt;p&gt;这跟激情有关，也是优秀程序员的一个特征。&lt;&#x2F;p&gt;
&lt;p&gt;我在 9 岁时就开始编程，那时还不是在 PC 上，后来迁移到了 PC，学了 Pascal。当我 14 岁时，用 C 和 Assembler 写了一个 raycasting 引擎。花费了大量的时间与显卡打交道，终于可以看到很酷的图形效果。在这之前，我只是个二流的程序员，没有信心做任何复杂的事情。当我完成它时，我收获了自信。我知道只要我想，再难的事情我都能搞定。&lt;&#x2F;p&gt;
&lt;p&gt;这会在我的简历上出现吗？不会&lt;&#x2F;p&gt;
&lt;p&gt;我深信大多数优秀的程序员都有类似的冰山不会出现在简历上。他们觉得这不是“合适的经历”。可以对那些潜在的优秀程序员问一个这样的问题“你能告诉我一个自己独立完成的项目吗？即使是不完整的，在业余时间开发的，没有出现在简历上？”如果他们不能，他们很可能不是优秀的程序员。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;5-duo-chong-ji-neng&quot;&gt;#5 多种技能&lt;&#x2F;h3&gt;
&lt;p&gt;这个很简单，由于对新鲜事物的热情和强烈的求知欲，那些 22 岁以上的程序员通常掌握好几门语言。这不可避免，学习一个新技术是最有意思的事情之一。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;6-zheng-shu&quot;&gt;#6 证书&lt;&#x2F;h3&gt;
&lt;p&gt;这其实不是一个优秀程序员的特征，很多有计算机相关证书，很多没有。年龄也一样，有些 18 岁就展露头角，有些 40 岁才有所成就。我的经历告诉我，大多数平凡或者差的程序员大学时才开始编程，为了他们的计算机课程。而优秀的程序员编程的历史可以追溯到更远。如果你的准程序员在大学前没有接触过变成，他所有的经历都是从第一份工作开始的，他很可能不是一个优秀的程序员。
声明&lt;&#x2F;p&gt;
&lt;p&gt;上面或者下面所说的特征不是必备的。你很可能会发现 NB 的程序员不符合这些特征。我的观点是，你不太可能找到一个优秀的程序员不符合这些特征中的任意一条。当然，你也会发现差的程序员也符合这些特征中的某几个。但我深信，一个程序员，这些特征符合地越多，那么他是优秀程序员的概率就越大，作为一个商人，你可以信赖这些人。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h3&gt;
&lt;p&gt;以下几个特征能够帮助你找到优秀的程序员&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对技术充满热情&lt;&#x2F;li&gt;
&lt;li&gt;编程是生活的一部分&lt;&#x2F;li&gt;
&lt;li&gt;会在你的耳边谈论技术相关的话题，如果你有兴趣的话&lt;&#x2F;li&gt;
&lt;li&gt;主动学习新技术&lt;&#x2F;li&gt;
&lt;li&gt;对自己不能认同的技术，感到不适应，无法全身心投入&lt;&#x2F;li&gt;
&lt;li&gt;聪明，对很多话题都感兴趣&lt;&#x2F;li&gt;
&lt;li&gt;在大学之前就开始接触编程了&lt;&#x2F;li&gt;
&lt;li&gt;有隐藏的冰山，自己完成的大项目&lt;&#x2F;li&gt;
&lt;li&gt;对许多不相关的技术有了解&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        
        
        <item>
            <title>(译)不再查看简历</title>
            <pubDate>Fri, 27 Aug 2010 00:00:00 +0000</pubDate>
            <link>https://limboy.me/posts/never-read-another-resume/</link>
            <guid>https://limboy.me/posts/never-read-another-resume/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.inc.com&#x2F;magazine&#x2F;20100601&#x2F;never-read-another-resume_Printer_Friendly.html&quot;&gt;原文&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;雇佣员工就像交朋友。好朋友能让你的生活丰富多彩。交友不慎会让你焦头烂额。跟谁一起工作比约谁一起出去重要得多，因为你跟同事相处的时间比跟朋友相处的时间要多。&lt;&#x2F;p&gt;
&lt;p&gt;等等，我为什么会谈到招人？解雇率不是很高吗？不是有很多人找不到工作吗？这在其他行业是很平常的事，但我们不是。事实上，我们公司的招聘版(为程序员和设计师提供职位)有大量的职位。我们最近还招了两个员工。&lt;&#x2F;p&gt;
&lt;p&gt;我想分享一下 37signals 是如何招聘的。我们很少会去招人，我们只有 20 个成员，但总结了一套方法，非常好用。11 年里，只有两位员工离开了 37signals，其中一个在七年后又重新回归。&lt;&#x2F;p&gt;
&lt;p&gt;我们是怎么做的呢？首先，我们不着急聘用，除非迫不得已。招人是为了减轻目前的负担，而不是作为人才储备。我们绝不允许自己有这样的举动。&lt;&#x2F;p&gt;
&lt;p&gt;如果遇上了合适的人，但没有合适的职位，我们会非常坦然地放弃。我认识好几个优秀的程序员和设计师，也愿意让他们加入我们的团队，但是很不巧，没有空位。&lt;&#x2F;p&gt;
&lt;p&gt;我见过好多公司为了那些优秀的人才而开辟职位，只是为了确保他们不会离开。但是招了人，却不让他们做正事，这是对他们的不尊重，对公司也没有好处。优秀的人总是希望能做一些确实有用的东西，这样的结果只能是走人(译者注：除非他想在薪资有保障的情况下，暗地里做自己的事，哈哈)&lt;&#x2F;p&gt;
&lt;p&gt;小团队逼迫着你专注，只做那些必须要做的，而不是想做的。必须学会安排优先级，专注下一件最重要的事。而不是”如果…，那多帅啊”，这样的事太多了。&lt;&#x2F;p&gt;
&lt;p&gt;如何知道你确实需要招人了？大概如下：你试着亲身去做这项工作吗？如果没有，那么你并没有真正理解该职位。在没有吃透的情况下，很难判断谁才是你想要的人。&lt;&#x2F;p&gt;
&lt;p&gt;几年前，我们想招一个业务拓展人员，他能解答合作伙伴的一些咨询以及发掘新的合作机会。因为我们总是忙着别的事情，很可能忽略了这类邮件。&lt;&#x2F;p&gt;
&lt;p&gt;于是我们开始一轮轮的面试，有些人有非常好的条件和经历。但是我们以前没有招过这样的人，本身也没有经验，所以很难继续跟候选人探讨下去，也无法确切地评定面试者的实际水平。&lt;&#x2F;p&gt;
&lt;p&gt;所以面了一堆人后，我们停止了脚步，开始自己来处里客户的咨询。很快发现，并没有想像的那么困难。如果没有做出这样的决定，很可能招了我们并不需要的人，这是我们不想看到的，这对该员工也不好。&lt;&#x2F;p&gt;
&lt;p&gt;我们也从别的职位中获取了这样的经验。在聘用第一个客服人员前，我处理所有的客户服务。大概花了两年的时间回复用户的电子邮件。在聘用第一个系统维护人员前，我的合作伙伴 David 和程序员 Jamis 负责处理所有的系统管理。最后我们找到了非常中意的人，因为我们太了解这个职位了。&lt;&#x2F;p&gt;
&lt;p&gt;在考察候选者时，我们也有一些小技巧。比如我们不看简历。就我个人的经验，它们无不夸大其词，半真半假，甚至一派胡言。即使他们不是有意要欺骗你，也会夸大事实。”5 年的经验”到底是什么意思？&lt;&#x2F;p&gt;
&lt;p&gt;我们真正看重的是自荐信。它说明了一切。它能告诉你这个人是想要这个职位还是其他任何职位。而且自荐信能让有些事情异常清晰：它能反映你的写作能力。拼写检查工具能检查拼写，但它们不能帮助你写作。还有一点：如果有几个差不多的，选择那个写得更好的。&lt;&#x2F;p&gt;
&lt;p&gt;我们也看他的努力程度，他到底有多想得到该职位？我们招了一个设计师 Jason Zimdars，因为 1) 他很优秀。 2) 他比其它人更想得到该职位。他专门为我们建了一个网站，列举了他的能力，很少有人能像他这么用心(jasonzimdars.com&#x2F;svn)。&lt;&#x2F;p&gt;
&lt;p&gt;面试期间，我们希望他能多提问题，但问题和问题还不一样。以”怎样”开头的问题，会在我们的心里亮红灯。我们更希望他问”为什么”，这是对某个领域感兴趣的表现。”怎样”是一个标志，说明他解决困难的能力不够，会更依赖他人。所以尽量少问”怎样才能”之类的问题。&lt;&#x2F;p&gt;
&lt;p&gt;在正式聘用前，我们会测试该候选人。我们给设计师一个礼拜的时间来完成某个任务，无论是否录用都会支付$1500 作为补偿。如果他还在工作，那就用一个月作为测试周期，给他一个实际的项目，考验他的压力承受能力，实际水平和沟通能力。用真实的项目作为测试帮助我们过滤了一些候选人，同时也把人才留了下来。&lt;&#x2F;p&gt;
&lt;p&gt;最后，我们不会让地理位置成为拦路虎。我们雇佣最优秀的人，无论他在哪里。我们的总部在芝加哥，但我们的程序员在 Idaho,California，系统管理员在 North Carolina 和 downstate Illinois，设计师在 Oklahoma 和 Colorado，一个写手在 New York City，其他人在欧洲。这明显不适合需要面对面交谈的，但对大多数人来说，这是可行的，人才到处都是，就看你能不能找到了。&lt;&#x2F;p&gt;
</description>
        </item>
        
    </channel>
</rss>